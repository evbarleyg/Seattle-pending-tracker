<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Seattle Housing Buyer Lens</title>
    <meta name="description" content="Interactive Seattle housing dashboard for buyers. Cross-filter neighborhood, property type, price bands, and sale timing using King County public record data." />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Seattle Housing Buyer Lens" />
    <meta property="og:description" content="Buyer-focused Seattle housing dashboard with dynamic filters, market KPIs, and row-level records." />
    <meta property="og:url" content="https://evbarleyg.github.io/Seattle-pending-tracker/" />
    <meta property="og:image" content="https://evbarleyg.github.io/Seattle-pending-tracker/assets/share-preview.svg" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Seattle Housing Buyer Lens" />
    <meta name="twitter:description" content="Interactive buyer dashboard for Seattle home sales and pricing pressure." />
    <meta name="twitter:image" content="https://evbarleyg.github.io/Seattle-pending-tracker/assets/share-preview.svg" />
    <link rel="icon" type="image/x-icon" href="./favicon.ico" />
    <link rel="icon" type="image/svg+xml" sizes="any" href="./favicon.svg" />
    <link rel="shortcut icon" href="./favicon.ico" />
    <link rel="apple-touch-icon" href="assets/ebg-icon.svg" />
    <meta name="theme-color" content="#1f5ea8" />
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin=""
    />
    <style>
      :root {
        --bg: #0a1220;
        --bg-elev: #111c2f;
        --bg-elev-2: #16243b;
        --line: #2a3e5f;
        --text: #ecf3ff;
        --muted: #9fb4d4;
        --primary: #4da6ff;
        --primary-2: #3dd59d;
        --warn: #e6b35a;
        --danger: #e6718c;
      }
      * { box-sizing: border-box; }
      body {
        margin: 0;
        background:
          radial-gradient(1100px 600px at -15% -25%, #17335f 0%, transparent 55%),
          radial-gradient(1000px 600px at 115% -15%, #4a1f59 0%, transparent 52%),
          var(--bg);
        color: var(--text);
        font-family: "Inter", "Segoe UI", "Helvetica Neue", Arial, sans-serif;
      }
      a { color: #95d0ff; text-decoration: none; }
      a:hover { text-decoration: underline; }
      .address-link {
        color: #2c6fc2;
        text-decoration: underline;
        text-underline-offset: 2px;
        font-weight: 600;
      }
      .address-link:hover {
        color: #1d57a0;
      }
      .addr-sub-link {
        margin-left: 6px;
        font-size: 11px;
        color: #45698f;
        text-decoration: underline;
        text-underline-offset: 2px;
        white-space: nowrap;
      }
      .addr-badge {
        margin-left: 6px;
        font-size: 10px;
        color: #4b6789;
        border: 1px solid #a6bfdc;
        border-radius: 999px;
        padding: 1px 6px;
        white-space: nowrap;
      }
      .addr-sub-link:hover {
        color: #1d4e84;
      }
      .ext-icon {
        margin-left: 4px;
        font-size: 11px;
        opacity: 0.85;
      }

      header {
        max-width: 1260px;
        margin: 0 auto;
        padding: 28px 22px 10px;
      }
      h1 {
        margin: 0;
        font-size: 34px;
        letter-spacing: 0.4px;
      }
      .subtitle {
        margin-top: 8px;
        color: var(--muted);
        font-size: 14px;
      }
      .status {
        margin-top: 8px;
        color: var(--muted);
        font-size: 12px;
      }

      .tabs {
        margin-top: 14px;
        display: inline-flex;
        border: 1px solid var(--line);
        border-radius: 999px;
        overflow: hidden;
        background: rgba(17, 28, 47, 0.88);
      }
      .tab {
        border: none;
        background: transparent;
        color: var(--muted);
        font-size: 13px;
        padding: 9px 14px;
        cursor: pointer;
      }
      .tab.active {
        color: #fff;
        background: linear-gradient(135deg, #275ea7, #2d8cb4);
      }
      .header-controls {
        margin-top: 14px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }
      .theme-toggle {
        border: 1px solid var(--line);
        border-radius: 999px;
        padding: 7px 12px;
        font-size: 12px;
        color: #d8e9ff;
        background: rgba(17, 28, 47, 0.88);
        cursor: pointer;
      }

      .app {
        max-width: 1260px;
        margin: 0 auto;
        padding: 14px 22px 30px;
        display: grid;
        gap: 14px;
      }
      .panel {
        background: linear-gradient(180deg, rgba(17,28,47,0.96), rgba(13,22,36,0.95));
        border: 1px solid var(--line);
        border-radius: 14px;
        padding: 14px;
        box-shadow: 0 12px 28px rgba(0,0,0,0.34);
      }
      .panel h3 {
        margin: 0 0 10px;
        font-size: 18px;
      }

      .filters {
        display: grid;
        grid-template-columns: repeat(8, minmax(0, 1fr));
        gap: 10px;
      }
      .filters-wrap > summary {
        list-style: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }
      .filters-wrap > summary::-webkit-details-marker {
        display: none;
      }
      .filters-wrap > summary h3 {
        margin: 0;
      }
      .filters-toggle {
        border: 1px solid var(--line);
        border-radius: 999px;
        padding: 4px 10px;
        font-size: 12px;
        color: var(--muted);
        background: #0f1b2f;
      }
      .filters-wrap .label-open {
        display: none;
      }
      .filters-wrap .label-closed {
        display: inline;
      }
      .filters-wrap[open] .label-open {
        display: inline;
      }
      .filters-wrap[open] .label-closed {
        display: none;
      }
      .filters-body {
        margin-top: 10px;
        display: grid;
        gap: 8px;
      }
      .field label {
        display: block;
        margin-bottom: 4px;
        color: var(--muted);
        font-size: 12px;
      }
      select, input {
        width: 100%;
        color: var(--text);
        background: #0c1728;
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 8px 10px;
        font-size: 14px;
      }
      input[type="range"] {
        padding: 0;
        height: 24px;
        background: transparent;
        accent-color: #2f83dd;
      }
      .range-value {
        margin-top: 2px;
        font-size: 12px;
        color: var(--muted);
      }
      .multi-dd {
        position: relative;
      }
      .multi-dd > summary {
        list-style: none;
        cursor: pointer;
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 8px 10px;
        background: #0c1728;
        color: var(--text);
        font-size: 14px;
      }
      .multi-dd > summary::-webkit-details-marker {
        display: none;
      }
      .multi-dd[open] > summary {
        border-color: #3e83cc;
      }
      .multi-dd-panel {
        position: absolute;
        z-index: 25;
        inset: calc(100% + 6px) 0 auto;
        border: 1px solid var(--line);
        border-radius: 12px;
        background: #0f1b2f;
        box-shadow: 0 14px 30px rgba(0, 0, 0, 0.38);
        padding: 10px;
      }
      .multi-dd-actions {
        display: flex;
        justify-content: space-between;
        margin-bottom: 8px;
        gap: 8px;
      }
      .mini-link {
        border: 1px solid #35547a;
        border-radius: 999px;
        background: #12233a;
        color: #dcecff;
        font-size: 11px;
        padding: 3px 8px;
        cursor: pointer;
      }
      .multi-dd-options {
        max-height: 260px;
        overflow: auto;
        display: grid;
        gap: 6px;
        padding-right: 2px;
      }
      .multi-opt {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 13px;
        color: #d8e8ff;
      }
      .multi-opt input {
        width: auto;
      }
      .actions {
        grid-column: 1 / -1;
        display: flex;
        align-items: center;
        gap: 6px;
        flex-wrap: wrap;
      }
      .field-wide {
        grid-column: span 2;
      }
      .flag-toggle {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        border: 1px solid var(--line);
        border-radius: 10px;
        background: #0f1b2f;
        padding: 7px 10px;
        font-size: 12px;
        color: #dcecff;
      }
      .flag-toggle input {
        width: auto;
        accent-color: #3d93ed;
      }
      .flag-badge {
        display: inline-block;
        margin-left: 6px;
        border: 1px solid #3b5f8c;
        border-radius: 999px;
        padding: 1px 6px;
        font-size: 10px;
        color: #d9e9ff;
      }
      .btn {
        border: 1px solid #2f76c4;
        border-radius: 10px;
        padding: 6px 10px;
        font-size: 12px;
        line-height: 1.2;
        white-space: nowrap;
        color: #fff;
        background: linear-gradient(135deg, #21589d, #2b93ba);
        cursor: pointer;
      }
      .btn.alt {
        border-color: var(--line);
        background: #0c1728;
        color: #d3e5ff;
      }
      .summary {
        margin-top: 8px;
        color: var(--muted);
        font-size: 12px;
      }
      .chips {
        margin-top: 8px;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }
      .chip {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 4px 8px;
        border-radius: 999px;
        border: 1px solid #35547a;
        background: #15253d;
        color: #d8e8ff;
        font-size: 12px;
      }
      .chip button {
        border: none;
        background: transparent;
        color: #9ec0e8;
        cursor: pointer;
      }

      .view { display: none; }
      .view.active { display: grid; gap: 14px; }

      .guide {
        margin: 0;
        padding-left: 18px;
        color: #dce9ff;
        display: grid;
        gap: 7px;
      }
      .insights {
        margin: 0;
        padding-left: 18px;
        display: grid;
        gap: 7px;
      }

      .kpi-grid {
        display: grid;
        grid-template-columns: repeat(6, minmax(0, 1fr));
        gap: 10px;
      }
      .kpi {
        border: 1px solid var(--line);
        border-radius: 12px;
        background: linear-gradient(180deg, #122440, #0f1d33);
        padding: 10px;
        display: grid;
        gap: 6px;
      }
      .kpi .label {
        color: var(--muted);
        font-size: 12px;
      }
      .kpi .value {
        font-size: 22px;
      }
      .kpi .kbtn {
        justify-self: start;
        border: 1px solid #37567a;
        border-radius: 999px;
        padding: 3px 8px;
        font-size: 11px;
        color: #dcecff;
        background: #12233a;
        cursor: pointer;
      }
      .kpi .kbtn.active {
        border-color: #4eb2ff;
      }

      .two-col {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 14px;
      }
      .geo-layout {
        display: grid;
        grid-template-columns: 1.35fr 1fr;
        gap: 14px;
        align-items: stretch;
      }
      .geo-main-panel,
      .geo-side-panel {
        display: flex;
        flex-direction: column;
        min-height: 920px;
      }
      .geo-map-wrap {
        border: 1px solid var(--line);
        border-radius: 14px;
        padding: 10px;
        background: linear-gradient(180deg, rgba(11, 22, 38, 0.8), rgba(11, 18, 32, 0.8));
      }
      #geoCanvas {
        width: 100%;
        height: 560px;
        border-radius: 10px;
        overflow: hidden;
      }
      .geo-map-wrap .leaflet-container {
        background: #d8e5f4;
      }
      .geo-marker-wrap {
        background: transparent;
        border: none;
      }
      .geo-bubble {
        width: var(--b-size, 28px);
        height: var(--b-size, 28px);
        border: 2px solid rgba(238, 246, 255, 0.95);
        border-radius: 999px;
        background: var(--b-color, #3d93ed);
        color: #f3f9ff;
        font-size: 11px;
        font-weight: 700;
        line-height: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.28);
        cursor: pointer;
      }
      .geo-bubble.active {
        border-color: #ffffff;
        box-shadow: 0 0 0 3px rgba(255,255,255,0.3);
      }
      .geo-bubble:hover {
        transform: scale(1.03);
      }
      .leaflet-tooltip.geo-tip {
        border-radius: 10px;
        border: 1px solid #7e9bc0;
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.28);
        font-size: 12px;
        line-height: 1.35;
        max-width: 320px;
        z-index: 900;
      }
      .geo-tip b {
        font-size: 12px;
      }
      .geo-tip-card {
        display: grid;
        gap: 4px;
        min-width: 220px;
      }
      .geo-tip-title {
        font-weight: 700;
        color: #142f4e;
      }
      .geo-tip-row {
        display: flex;
        justify-content: space-between;
        gap: 8px;
      }
      .geo-tip-row .k {
        color: #3f5e84;
      }
      .geo-tip-row .v {
        color: #0f2e50;
        font-weight: 600;
        text-align: right;
      }
      .geo-note {
        margin-top: 8px;
        color: var(--muted);
        font-size: 12px;
      }
      .geo-legend {
        display: flex;
        flex-wrap: wrap;
        gap: 10px 14px;
        margin-top: 8px;
        font-size: 12px;
        color: var(--muted);
      }
      .geo-legend-item {
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }
      .geo-dot {
        width: 10px;
        height: 10px;
        border-radius: 999px;
        display: inline-block;
      }
      .geo-dot.exact {
        background: #5fd89c;
        border: 1px solid #103520;
      }
      .geo-dot.sa-low { background: hsl(220 74% 56%); border: 1px solid #123b62; }
      .geo-dot.sa-mid { background: hsl(168 74% 56%); border: 1px solid #0f4a44; }
      .geo-dot.sa-high { background: hsl(95 74% 56%); border: 1px solid #2b4d11; }
      .geo-dot.selected { background: transparent; border: 2px solid #f9d26b; }
      .geo-selected-wrap {
        margin-top: 10px;
        border: 1px solid var(--line);
        border-radius: 12px;
        background: rgba(20, 35, 58, 0.5);
        padding: 10px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        min-height: 250px;
        flex: 1;
      }
      .geo-selected-head {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }
      .geo-selected-title {
        font-weight: 700;
        color: #eaf2ff;
      }
      .geo-selected-controls {
        display: flex;
        align-items: center;
        gap: 8px;
        color: var(--muted);
        font-size: 12px;
      }
      .geo-vp-toggle {
        display: inline-flex;
        align-items: center;
        gap: 5px;
        cursor: pointer;
      }
      .geo-vp-toggle input {
        accent-color: #3d93ed;
      }
      .geo-selected-table-wrap {
        flex: 1;
        min-height: 0;
        overflow-y: auto;
      }
      .geo-mobile-list {
        display: none;
        gap: 8px;
      }
      .geo-mobile-card {
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 8px;
        background: rgba(16, 31, 52, 0.7);
        display: grid;
        gap: 4px;
        width: 100%;
        text-align: left;
      }
      button.geo-mobile-card {
        cursor: pointer;
      }
      button.geo-mobile-card.active {
        border-color: #4eb2ff;
      }
      .geo-mobile-card .k {
        font-size: 11px;
        color: var(--muted);
      }
      .geo-mobile-card .v {
        font-size: 13px;
        color: var(--text);
      }
      .geo-kpis {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
        margin-bottom: 10px;
      }
      .geo-kpi {
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 8px;
        background: rgba(20, 35, 58, 0.54);
      }
      .geo-kpi .label {
        color: var(--muted);
        font-size: 11px;
      }
      .geo-kpi .value {
        font-size: 18px;
        margin-top: 2px;
      }
      .geo-insights-table-wrap {
        max-height: 310px;
        overflow-y: auto;
      }
      .geo-selected-wrap-right {
        flex: 1;
        min-height: 0;
      }
      .chart {
        display: grid;
        gap: 8px;
      }
      .vchart {
        min-height: 280px;
        display: grid;
        grid-template-columns: 58px 1fr;
        gap: 10px;
      }
      .y-axis {
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        align-items: flex-end;
        color: var(--muted);
        font-size: 11px;
        padding: 2px 0 18px;
      }
      .plot {
        border-left: 1px solid #2d4363;
        border-bottom: 1px solid #2d4363;
        padding: 6px 6px 0 8px;
        display: grid;
        grid-template-columns: repeat(var(--cols, 1), minmax(0, 1fr));
        gap: 8px;
        align-items: end;
        min-width: 0;
      }
      .vbar {
        border: 1px solid #2d4363;
        border-radius: 10px 10px 0 0;
        background: #0f1b2f;
        color: #dce8ff;
        cursor: pointer;
        display: grid;
        grid-template-rows: 1fr auto auto;
        padding: 6px 4px 4px;
        min-height: 165px;
      }
      .vbar.active {
        border-color: #4eb2ff;
      }
      .vbar-track {
        align-self: end;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: end;
        justify-content: center;
      }
      .vbar-fill {
        display: block;
        width: 78%;
        border-radius: 8px 8px 0 0;
        background: linear-gradient(180deg, #56d1ff, #3d93ed);
        min-height: 6px;
      }
      .vbar-fill.warm {
        background: linear-gradient(180deg, #f3c366, #cc8536);
      }
      .vbar-month {
        margin-top: 6px;
        text-align: center;
        font-size: 11px;
        color: #dce8ff;
        line-height: 1.1;
      }
      .vbar-value {
        margin-top: 2px;
        text-align: center;
        font-size: 11px;
        color: #b8cae4;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        font-size: 13px;
      }
      .table-wrap {
        width: 100%;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        overscroll-behavior-x: contain;
        scroll-behavior: smooth;
      }
      .record-mobile-list {
        display: none;
        gap: 8px;
      }
      .mrow {
        border: 1px solid var(--line);
        border-radius: 10px;
        background: linear-gradient(180deg, rgba(18,36,63,0.7), rgba(12,25,44,0.64));
      }
      .mrow-head {
        width: 100%;
        border: none;
        background: transparent;
        color: var(--text);
        cursor: pointer;
        padding: 10px 10px;
        display: grid;
        grid-template-columns: minmax(0, 1fr) auto auto;
        gap: 8px;
        align-items: center;
        text-align: left;
      }
      .mrow-address {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        font-size: 12px;
        font-weight: 600;
      }
      .mrow-price {
        font-size: 13px;
        font-weight: 700;
      }
      .mrow-date {
        font-size: 11px;
        color: var(--muted);
      }
      .mrow-toggle {
        margin-left: 6px;
        font-size: 11px;
        color: var(--muted);
      }
      .mrow-detail {
        display: none;
        border-top: 1px solid rgba(42,62,95,0.55);
        padding: 8px;
      }
      .mrow.expanded .mrow-detail {
        display: block;
      }
      .mrow-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 6px;
      }
      .mrow-item {
        border: 1px solid var(--line);
        border-radius: 8px;
        padding: 6px;
        background: rgba(14, 28, 49, 0.68);
      }
      .mrow-item .k {
        font-size: 11px;
        color: var(--muted);
      }
      .mrow-item .v {
        margin-top: 2px;
        font-size: 12px;
      }
      th, td {
        text-align: left;
        padding: 8px 6px;
        border-bottom: 1px solid rgba(42,62,95,0.78);
      }
      th {
        color: var(--muted);
        font-weight: 600;
      }
      .th-sort {
        appearance: none;
        border: none;
        background: transparent;
        color: inherit;
        font: inherit;
        font-weight: 600;
        padding: 0;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }
      .th-sort.active {
        color: var(--text);
      }
      .sort-ind {
        font-size: 11px;
        opacity: 0.8;
      }
      tr.clickable { cursor: pointer; }
      tr.clickable:hover { background: rgba(56,92,147,0.16); }
      tr.clickable.active { background: rgba(78,178,255,0.17); }

      .mini-btn {
        border: 1px solid #35547a;
        border-radius: 999px;
        background: #12233a;
        color: #dcecff;
        font-size: 11px;
        padding: 2px 8px;
        cursor: pointer;
      }
      .mini-btn.active {
        border-color: #4eb2ff;
      }
      .mode {
        display: inline-block;
        border: 1px solid #35547a;
        border-radius: 999px;
        background: #15253d;
        color: #dcecff;
        font-size: 11px;
        padding: 2px 8px;
      }
      .hot-pill {
        display: inline-block;
        border-radius: 999px;
        padding: 2px 8px;
        font-size: 11px;
        border: 1px solid #35547a;
        color: #dcecff;
        background: #15253d;
        white-space: nowrap;
      }
      .hot-pill.ultra {
        border-color: #5e4aa0;
        background: rgba(119, 93, 207, 0.22);
        color: #eaddff;
      }
      .hot-pill.hot {
        border-color: #2f7f9d;
        background: rgba(61, 164, 206, 0.2);
        color: #ddf3ff;
      }
      .heat {
        display: inline-block;
        min-width: 92px;
        border-radius: 8px;
        padding: 3px 6px;
      }

      .mono {
        font-family: "SFMono-Regular", Menlo, Consolas, monospace;
        font-size: 12px;
        background: #0b1526;
        border: 1px solid var(--line);
        border-radius: 10px;
        white-space: pre-wrap;
        padding: 10px;
      }
      .note {
        margin-top: 8px;
        color: var(--muted);
        font-size: 12px;
      }

      /* Light theme defaults for readability */
      body.light {
        --line: #c7d4e7;
        --text: #14233b;
        --muted: #516884;
        background:
          radial-gradient(1100px 600px at -15% -25%, #d7e7ff 0%, transparent 55%),
          radial-gradient(1000px 600px at 115% -15%, #efe2ff 0%, transparent 52%),
          #f3f8ff;
      }
      body.light a { color: #1f5ea8; }
      body.light .address-link {
        color: #1f5ea8;
      }
      body.light .address-link:hover {
        color: #17467e;
      }
      body.light .addr-sub-link {
        color: #355b84;
      }
      body.light .addr-badge {
        color: #486784;
        border-color: #acc2db;
        background: #f1f7ff;
      }
      body.light .tabs {
        background: rgba(255, 255, 255, 0.88);
        border-color: #bfd0e6;
      }
      body.light .tab { color: #3c5777; }
      body.light .tab.active { color: #fff; }
      body.light .theme-toggle {
        color: #294768;
        background: rgba(255, 255, 255, 0.9);
        border-color: #bfd0e6;
      }
      body.light .panel {
        background: linear-gradient(180deg, rgba(255,255,255,0.96), rgba(248,252,255,0.96));
        border-color: #c6d4e5;
        box-shadow: 0 10px 24px rgba(26, 59, 102, 0.12);
      }
      body.light .geo-map-wrap {
        border-color: #c6d4e5;
        background: linear-gradient(180deg, rgba(246, 251, 255, 0.95), rgba(238, 246, 255, 0.95));
      }
      body.light .geo-kpi {
        border-color: #c7d5e8;
        background: #f3f8ff;
      }
      body.light .geo-bubble {
        color: #0f2b49;
        border-color: #f7fbff;
      }
      body.light .leaflet-tooltip.geo-tip {
        border-color: #b9cde2;
      }
      body.light .geo-tip-title {
        color: #132d4b;
      }
      body.light .geo-tip-row .k {
        color: #466485;
      }
      body.light .geo-tip-row .v {
        color: #173557;
      }
      body.light select,
      body.light input {
        color: #1a2f4a;
        background: #ffffff;
        border-color: #bccde2;
      }
      body.light .range-value { color: #516884; }
      body.light .multi-dd > summary {
        color: #1a2f4a;
        background: #ffffff;
        border-color: #bccde2;
      }
      body.light .multi-dd-panel {
        background: #ffffff;
        border-color: #c4d4e8;
        box-shadow: 0 12px 28px rgba(23, 60, 105, 0.16);
      }
      body.light .mini-link {
        border-color: #b9cce5;
        background: #eaf3ff;
        color: #214767;
      }
      body.light .flag-toggle {
        color: #224463;
        background: #ffffff;
        border-color: #bccde2;
      }
      body.light .flag-badge {
        color: #2b4f73;
        border-color: #b4c8e2;
        background: #edf4ff;
      }
      body.light .multi-opt { color: #234261; }
      body.light .btn.alt {
        color: #274667;
        background: #ffffff;
        border-color: #b8cadf;
      }
      body.light .chip {
        background: #edf4ff;
        border-color: #c4d4ea;
        color: #244160;
      }
      body.light .chip button { color: #476a91; }
      body.light .filters-toggle {
        border-color: #bccde2;
        background: #ffffff;
        color: #4f6783;
      }
      body.light .guide,
      body.light .insights { color: #1f3552; }
      body.light .kpi {
        background: linear-gradient(180deg, #f7fbff, #edf5ff);
        border-color: #c8d7eb;
      }
      body.light .kpi .kbtn {
        background: #eaf3ff;
        border-color: #b9cde5;
        color: #244665;
      }
      body.light .plot {
        border-left-color: #c7d5e8;
        border-bottom-color: #c7d5e8;
      }
      body.light .vbar {
        background: #ffffff;
        border-color: #c7d5e8;
        color: #1f3855;
      }
      body.light .vbar-fill { background: linear-gradient(180deg, #42bde7, #2d80d7); }
      body.light .vbar-fill.warm { background: linear-gradient(180deg, #e3b24f, #c07b2f); }
      body.light .vbar-month { color: #1f3855; }
      body.light .vbar-value { color: #4a6586; }
      body.light th,
      body.light td { border-bottom-color: #d2deed; }
      body.light tr.clickable:hover { background: rgba(77, 133, 200, 0.12); }
      body.light tr.clickable.active { background: rgba(77, 166, 255, 0.17); }
      body.light .mini-btn {
        border-color: #b9cce5;
        background: #eaf3ff;
        color: #214767;
      }
      body.light .mode {
        border-color: #b9cce5;
        background: #edf4ff;
        color: #214767;
      }
      body.light .hot-pill {
        border-color: #b9cce5;
        background: #edf4ff;
        color: #214767;
      }
      body.light .hot-pill.ultra {
        border-color: #bcaee6;
        background: #f2eeff;
        color: #463a83;
      }
      body.light .hot-pill.hot {
        border-color: #a9cbe2;
        background: #ebf7ff;
        color: #1f5f7d;
      }
      body.light .mono {
        background: #f7fbff;
        border-color: #c5d4e7;
      }
      body.light .mrow {
        border-color: #c7d5e8;
        background: linear-gradient(180deg, #f9fcff, #f3f8ff);
      }
      body.light .mrow-item {
        border-color: #c7d5e8;
        background: #ffffff;
      }
      body.light .geo-selected-wrap,
      body.light .geo-kpi {
        border-color: #c8d7eb;
        background: rgba(237, 245, 255, 0.75);
      }
      body.light .geo-selected-title {
        color: #1f3d60;
      }
      body.light .geo-selected-controls {
        color: #4a6586;
      }
      body.light .geo-dot.exact {
        border-color: #2f7e59;
      }
      body.light .geo-dot.sa-low { border-color: #155280; }
      body.light .geo-dot.sa-mid { border-color: #13645d; }
      body.light .geo-dot.sa-high { border-color: #3f5f16; }
      body.light .geo-dot.selected { border-color: #956f0b; }
      body.light .geo-mobile-card {
        border-color: #c8d7eb;
        background: rgba(247, 251, 255, 0.88);
      }

      @media (max-width: 1120px) {
        .filters { grid-template-columns: repeat(4, minmax(0, 1fr)); }
        .field-wide { grid-column: span 2; }
        .kpi-grid { grid-template-columns: repeat(3, minmax(0, 1fr)); }
        .two-col { grid-template-columns: 1fr; }
        .geo-layout { grid-template-columns: 1fr; }
        .geo-main-panel,
        .geo-side-panel {
          min-height: 0;
        }
      }
      @media (max-width: 680px) {
        .filters { grid-template-columns: 1fr; }
        .field-wide { grid-column: span 1; }
        .kpi-grid { grid-template-columns: 1fr 1fr; }
        .header-controls {
          flex-direction: column;
          align-items: flex-start;
        }
        .tabs {
          width: 100%;
          overflow-x: auto;
          flex-wrap: nowrap;
          white-space: nowrap;
          -webkit-overflow-scrolling: touch;
          padding-bottom: 2px;
        }
        .tab {
          flex: 0 0 auto;
          padding: 8px 11px;
          font-size: 12px;
        }
        header {
          padding: 20px 14px 8px;
        }
        .app {
          padding: 10px 14px 20px;
        }
        h1 {
          font-size: 28px;
        }
        .vchart {
          min-height: 206px;
          grid-template-columns: 38px 1fr;
        }
        .plot {
          gap: 4px;
          padding: 4px 4px 0 6px;
        }
        .vbar {
          min-height: 146px;
          padding: 4px 2px 2px;
        }
        .vbar-month {
          font-size: 10px;
        }
        .vbar-value {
          font-size: 10px;
        }
        .y-axis {
          font-size: 10px;
          padding-bottom: 14px;
        }
        .multi-dd-panel {
          position: fixed;
          left: 14px;
          right: 14px;
          inset: auto 14px 14px;
          max-height: 50vh;
        }
        .panel {
          padding: 10px;
        }
        .actions {
          flex-wrap: nowrap;
          overflow-x: auto;
          -webkit-overflow-scrolling: touch;
          padding-bottom: 3px;
        }
        .btn {
          flex: 0 0 auto;
          padding: 5px 9px;
          font-size: 11px;
        }
        #geoCanvas {
          height: min(50vh, 430px);
        }
        .geo-selected-wrap {
          min-height: 210px;
        }
        .geo-selected-head {
          flex-direction: column;
          align-items: flex-start;
        }
        .geo-selected-controls {
          width: 100%;
          justify-content: space-between;
          flex-wrap: wrap;
        }
        .geo-selected-table-wrap,
        .geo-insights-table-wrap {
          display: none;
        }
        .geo-mobile-list {
          display: grid;
        }
        #view-records .table-wrap {
          display: none;
        }
        .record-mobile-list {
          display: grid;
        }
      }
    </style>
  </head>
  <body class="light">
    <header>
      <h1>Seattle Housing Buyer Lens</h1>
      <div class="subtitle">Buyer-focused market view for Seattle. Built on public-record sales, with optional MLS fields when available. Every chart and metric can filter the entire dashboard.</div>
      <div class="header-controls">
        <div class="tabs" role="tablist">
          <button class="tab active" data-view="overview" role="tab">Overview</button>
          <button class="tab" data-view="charts" role="tab">Charts</button>
          <button class="tab" data-view="heat" role="tab">Hot Market</button>
          <button class="tab" data-view="geo" role="tab">Geo</button>
          <button class="tab" data-view="records" role="tab">Records</button>
          <button class="tab" data-view="data" role="tab">Data</button>
        </div>
        <button class="theme-toggle" id="themeToggle" type="button">Switch To Dark Mode</button>
      </div>
      <div class="status" id="datasetStatus">Initializing dataset...</div>
    </header>

    <main class="app">
      <section class="panel">
        <details class="filters-wrap" id="globalFilters">
          <summary>
            <h3>Global Filters</h3>
            <span class="filters-toggle">
              <span class="label-closed">Show Filters</span>
              <span class="label-open">Hide Filters</span>
            </span>
          </summary>
          <div class="filters-body">
            <div class="filters">
              <div class="field">
                <label for="fNeighborhoodSummary">Neighborhoods</label>
                <details class="multi-dd" id="fNeighborhood">
                  <summary id="fNeighborhoodSummary">All neighborhoods</summary>
                  <div class="multi-dd-panel">
                    <div class="multi-dd-actions">
                      <button class="mini-link" id="fNeighborhoodSelectAll" type="button">Select All</button>
                      <button class="mini-link" id="fNeighborhoodClear" type="button">Clear</button>
                    </div>
                    <div class="multi-dd-options" id="fNeighborhoodOptions"></div>
                  </div>
                </details>
              </div>
              <div class="field">
                <label for="fType">Property Type</label>
                <select id="fType"></select>
              </div>
              <div class="field">
                <label for="fMode">Data Mode</label>
                <select id="fMode">
                  <option value="All">All</option>
                  <option value="PUBLIC_PROXY">Public Proxy</option>
                  <option value="MLS_ENRICHED">MLS Enriched</option>
                </select>
              </div>
              <div class="field">
                <label for="fScope">Scope</label>
                <select id="fScope">
                  <option value="all">All Sales</option>
                  <option value="hot10">Hot Market (DOM/Pending <= 10 Days)</option>
                  <option value="ultra5">Ultra Hot (DOM/Pending <= 5 Days)</option>
                </select>
              </div>
              <div class="field">
                <label for="fMinClose">Min Close Price</label>
                <input id="fMinClose" type="range" />
                <div class="range-value" id="fMinCloseValue">$0</div>
              </div>
              <div class="field">
                <label for="fMaxClose">Max Close Price</label>
                <input id="fMaxClose" type="range" />
                <div class="range-value" id="fMaxCloseValue">$0</div>
              </div>
              <div class="field">
                <label for="fDateFrom">Sale Date From</label>
                <input id="fDateFrom" type="date" />
              </div>
              <div class="field">
                <label for="fDateTo">Sale Date To</label>
                <input id="fDateTo" type="date" />
              </div>
              <div class="field field-wide">
                <label for="ffProjection">Feature Flags</label>
                <label class="flag-toggle">
                  <input id="ffProjection" type="checkbox" />
                  Pending Price Projection
                  <span class="flag-badge">Experimental</span>
                </label>
              </div>
              <div class="actions">
                <button class="btn" id="exportCsvBtn" type="button">Export CSV</button>
                <button class="btn alt" id="resetBtn" type="button">Reset</button>
                <button class="btn alt" id="clearCrossBtn" type="button">Clear Cross-Filters</button>
              </div>
            </div>
            <div class="summary" id="filterSummary">No data loaded.</div>
            <div class="chips" id="activeChips"></div>
          </div>
        </details>
      </section>

      <section id="view-overview" class="view active">
        <section class="panel">
          <h3>How To Use This Dashboard</h3>
          <ul class="guide">
            <li>App opens with default filters set to <strong>Single Family</strong> and <strong>$1.1M-$1.4M</strong> so you can start with a focused buy-box view.</li>
            <li>Start with price/date filters to define your buy box, then click chart rows or table rows to drill down.</li>
            <li>Every interactive metric and chart item applies a cross-filter across all tabs.</li>
            <li>Use the chips row to remove individual cross-filters, or click Clear Cross-Filters.</li>
            <li>Public Proxy mode has county-close data and parcel details; MLS Enriched mode adds listing, pending, DOM, and bid-up behavior, including MLS sold records not yet posted in county sales exports.</li>
            <li>Hot Market is tagged where MLS <strong>DOM <= 10 days</strong> (or list-to-pending <= 10 days), and Ultra Hot is <strong>&le; 5 days</strong>.</li>
          </ul>
        </section>

        <div class="kpi-grid">
          <article class="kpi">
            <div class="label">Sales Count</div>
            <div class="value" id="kSales">0</div>
            <button class="kbtn" data-kpi-action="clear">Clear Cross-Filters</button>
          </article>
          <article class="kpi">
            <div class="label">Median Close Price</div>
            <div class="value" id="kMedianClose">$0</div>
            <button class="kbtn" data-kpi-action="closeTier">Filter Close >= Median</button>
          </article>
          <article class="kpi">
            <div class="label">Median Sale / List@Pending</div>
            <div class="value" id="kMedianSA">0.00x</div>
            <button class="kbtn" data-kpi-action="ratioMid">Filter 1.00x - 1.05x</button>
          </article>
          <article class="kpi">
            <div class="label">Share Above List@Pending</div>
            <div class="value" id="kAboveAssessed">0%</div>
            <button class="kbtn" data-kpi-action="ratioGt1">Filter S/List > 1.00x</button>
          </article>
          <article class="kpi">
            <div class="label">Median Price / SqFt</div>
            <div class="value" id="kPsf">$0</div>
            <button class="kbtn" data-kpi-action="psfTier">Filter $/SqFt >= Median</button>
          </article>
          <article class="kpi">
            <div class="label">Median Days To Pending (MLS, if available)</div>
            <div class="value" id="kPendingDays">n/a</div>
            <button class="kbtn" data-kpi-action="mlsOnly">Filter MLS Rows (if any)</button>
          </article>
        </div>

        <section class="panel">
          <h3>Current Slice Readout</h3>
          <ul class="insights" id="insights"></ul>
        </section>
      </section>

      <section id="view-charts" class="view">
        <div class="two-col">
          <section class="panel">
            <h3>Monthly Sales Volume</h3>
            <div class="chart" id="chartVolume"></div>
          </section>
          <section class="panel">
            <h3>Monthly Median Close Price</h3>
            <div class="chart" id="chartMedian"></div>
          </section>
        </div>
        <div class="two-col">
          <section class="panel">
            <h3>Sale / List@Pending Buckets</h3>
            <div class="table-wrap">
              <table>
                <thead>
                  <tr><th>Bucket</th><th>Count</th><th>Share</th><th>Median Close</th></tr>
                </thead>
                <tbody id="ratioRows"></tbody>
              </table>
            </div>
          </section>
          <section class="panel">
            <h3>Neighborhood Leaderboard</h3>
            <div class="table-wrap">
              <table>
                <thead>
                  <tr><th>Neighborhood</th><th>Count</th><th>Median Close</th><th>Median S/List</th></tr>
                </thead>
                <tbody id="rankRows"></tbody>
              </table>
            </div>
          </section>
        </div>
      </section>

      <section id="view-heat" class="view">
        <section class="panel">
          <h3>Hot Market Sample (<= 10 Days, Ultra <= 5 Days)</h3>
          <div class="kpi-grid">
            <article class="kpi">
              <div class="label">Hot-Market Share (<=10d, MLS)</div>
              <div class="value" id="hHotShare">0%</div>
              <button class="kbtn" data-set-interaction="hotMarket" data-set-value="hot">Filter Hot Market</button>
            </article>
            <article class="kpi">
              <div class="label">Ultra-Hot Share (<=5d, MLS)</div>
              <div class="value" id="hUltraShare">0%</div>
              <button class="kbtn" data-set-interaction="hotMarket" data-set-value="ultra">Filter Ultra Hot</button>
            </article>
            <article class="kpi">
              <div class="label">Median Sale / List</div>
              <div class="value" id="hMedianSL">0.00x</div>
              <div class="note">For homes tagged as hot market in this slice.</div>
            </article>
            <article class="kpi">
              <div class="label">Median Bid-Up</div>
              <div class="value" id="hMedianBid">$0</div>
              <div class="note">Close minus list-at-pending.</div>
            </article>
            <article class="kpi">
              <div class="label">Median DOM</div>
              <div class="value" id="hMedianDOM">n/a</div>
              <div class="note">MLS DOM for the hot-market sample.</div>
            </article>
          </div>
          <div class="table-wrap">
            <table>
              <thead>
                <tr><th>Neighborhood</th><th>Hot Sales</th><th>Median DOM</th><th>Median Sale/List</th><th>Above List</th></tr>
              </thead>
              <tbody id="hotRows"></tbody>
            </table>
          </div>
          <div class="note">Hot Market tag = MLS DOM/list-to-pending <= 10 days. Ultra Hot tag = <= 5 days.</div>
        </section>
      </section>

      <section id="view-records" class="view">
        <section class="panel">
          <h3>Row-Level Summary</h3>
          <div class="table-wrap">
            <table>
              <thead>
                <tr>
                  <th><button class="th-sort" type="button" data-record-sort="address">Address <span class="sort-ind" data-sort-ind="address">&#8597;</span></button></th>
                  <th><button class="th-sort" type="button" data-record-sort="neighborhood">Neighborhood <span class="sort-ind" data-sort-ind="neighborhood">&#8597;</span></button></th>
                  <th><button class="th-sort" type="button" data-record-sort="type">Type <span class="sort-ind" data-sort-ind="type">&#8597;</span></button></th>
                  <th><button class="th-sort" type="button" data-record-sort="beds">Beds <span class="sort-ind" data-sort-ind="beds">&#8597;</span></button></th>
                  <th><button class="th-sort" type="button" data-record-sort="baths">Baths <span class="sort-ind" data-sort-ind="baths">&#8597;</span></button></th>
                  <th><button class="th-sort" type="button" data-record-sort="sqft">SqFt <span class="sort-ind" data-sort-ind="sqft">&#8597;</span></button></th>
                  <th><button class="th-sort" type="button" data-record-sort="saleDate">Sale Date <span class="sort-ind" data-sort-ind="saleDate">&#8597;</span></button></th>
                  <th><button class="th-sort" type="button" data-record-sort="closePrice">Close Price <span class="sort-ind" data-sort-ind="closePrice">&#8597;</span></button></th>
                  <th><button class="th-sort" type="button" data-record-sort="listPriceAtPending">List@Pending <span class="sort-ind" data-sort-ind="listPriceAtPending">&#8597;</span></button></th>
                  <th><button class="th-sort" type="button" data-record-sort="domMetric">DOM <span class="sort-ind" data-sort-ind="domMetric">&#8597;</span></button></th>
                  <th><button class="th-sort" type="button" data-record-sort="hotCategory">Hot Category <span class="sort-ind" data-sort-ind="hotCategory">&#8597;</span></button></th>
                  <th><button class="th-sort" type="button" data-record-sort="saleToList">S/List <span class="sort-ind" data-sort-ind="saleToList">&#8597;</span></button></th>
                  <th><button class="th-sort" type="button" data-record-sort="delta">Delta vs List@Pending <span class="sort-ind" data-sort-ind="delta">&#8597;</span></button></th>
                  <th><button class="th-sort" type="button" data-record-sort="dataMode">Data Mode <span class="sort-ind" data-sort-ind="dataMode">&#8597;</span></button></th>
                </tr>
              </thead>
              <tbody id="recordRows"></tbody>
            </table>
          </div>
          <div class="record-mobile-list" id="recordMobileList"></div>
          <div class="note">Address links open Zillow search results. Use <strong>KC Record</strong> for official King County parcel/sale lookup when Zillow history is incomplete.</div>
        </section>
      </section>

      <section id="view-geo" class="view">
        <div class="geo-layout">
          <section class="panel geo-main-panel">
            <h3>Seattle Neighborhood Map</h3>
            <div class="geo-map-wrap" id="geoMap"></div>
            <div class="geo-note">Basemap: OpenStreetMap. Zoom in for exact parcel-coordinate property pins only. Click dots to add/remove property filters that update the full dashboard and row-level records.</div>
            <div class="geo-legend">
              <span class="geo-legend-item"><span class="geo-dot exact"></span>Exact parcel coordinate</span>
              <span class="geo-legend-item"><span class="geo-dot sa-low"></span>Lower S/List</span>
              <span class="geo-legend-item"><span class="geo-dot sa-mid"></span>Mid S/List</span>
              <span class="geo-legend-item"><span class="geo-dot sa-high"></span>Higher S/List</span>
              <span class="geo-legend-item"><span class="geo-dot selected"></span>Selected property</span>
            </div>
          </section>
          <section class="panel geo-side-panel">
            <h3>Neighborhood Geo Insights</h3>
            <div class="geo-kpis">
              <div class="geo-kpi">
                <div class="label">Neighborhoods In Slice</div>
                <div class="value" id="geoCount">0</div>
              </div>
              <div class="geo-kpi">
                <div class="label">Exact Pin Coverage</div>
                <div class="value" id="geoCoverage">0%</div>
              </div>
              <div class="geo-kpi">
                <div class="label">Highest Median Close</div>
                <div class="value" id="geoTopPrice">n/a</div>
              </div>
              <div class="geo-kpi">
                <div class="label">Highest Median S/List</div>
                <div class="value" id="geoTopRatio">n/a</div>
              </div>
            </div>
            <div class="table-wrap geo-insights-table-wrap">
              <table>
                <thead>
                  <tr><th>Neighborhood</th><th>Sales</th><th>Median Close</th><th>Median S/List</th><th>Above 1.0x</th></tr>
                </thead>
                <tbody id="geoRows"></tbody>
              </table>
            </div>
            <div class="geo-selected-wrap geo-selected-wrap-right">
              <div class="geo-selected-head">
                <div class="geo-selected-title">Property Selection From Map Dots</div>
                <div class="geo-selected-controls">
                  <label class="geo-vp-toggle"><input type="checkbox" id="geoViewportFilter" /> Filter to map viewport</label>
                  <span id="geoSelectedCount">0 selected</span>
                  <button type="button" class="mini-btn" id="geoClearSelection">Clear</button>
                </div>
              </div>
              <div class="table-wrap geo-selected-table-wrap">
                <table>
                  <thead>
                    <tr><th>Address</th><th>Neighborhood</th><th>List</th><th>Sale</th><th>DOM</th><th>Hot</th><th>Date</th></tr>
                  </thead>
                  <tbody id="geoSelectedRows"></tbody>
                </table>
              </div>
              <div class="geo-mobile-list" id="geoSelectedMobile"></div>
            </div>
            <div class="geo-mobile-list" id="geoInsightsMobile"></div>
          </section>
        </div>
      </section>

      <section id="view-data" class="view">
        <section class="panel">
          <h3>Data Source</h3>
          <div class="note" id="uploadStatus">Auto-load enabled for the default dataset.</div>

          <p class="note">Auto-load filename:</p>
          <div class="mono">public_sales_proxy_mls_enriched_last12mo.csv</div>

          <p class="note">Minimum columns:</p>
          <div class="mono">id,address,type,closePrice</div>

          <p class="note">Recommended columns:</p>
          <div class="mono">dataMode,addressSource,major,minor,parcelNbr,lat,lon,neighborhood,typeCode,zip,listDate,pendingDate,saleDate,listPriceAtPending,closePrice,beds,baths,sqft,yearBuilt,mlsListDate,mlsPendingDate,mlsListPriceAtPending,mlsClosePrice,mlsDOM,mlsCDOM,hotMarketTag,saleToListRatio,bidUpAmount,bidUpPct</div>

          <p class="note">Intended use:</p>
          <div class="mono">Buyer-side neighborhood and pricing-pressure analysis for Seattle. PUBLIC_PROXY mode uses public record fields. MLS_ENRICHED can add original listing timeline details when available.</div>
        </section>
      </section>
    </main>

    <script
      src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
      crossorigin=""
    ></script>
    <script>
      const DEFAULT_DATASET = "public_sales_proxy_mls_enriched_last12mo.csv";
      const DEFAULT_MIN_CLOSE = 1100000;
      const DEFAULT_MAX_CLOSE = 1400000;
      const PRICE_SLIDER_MIN = 0;
      const PRICE_SLIDER_CAP = 3000000;
      const PRICE_SLIDER_STEP = 10000;
      const GEO_DETAIL_ZOOM = 13;

      const TYPE_LABELS = {
        "11": "Single Family",
        "12": "Multi-Family (2-4 Units)",
        "13": "Multi-Family (5+ Units)",
        "14": "Condo",
        "15": "Mobile home park/court",
        "18": "Other Residential",
        "19": "Vacation/cabin",
        "50": "Commercial / Non-Residential Condo",
        "91": "Land",
      };

      const ZIP_NEIGHBORHOOD = {
        "98101": "Downtown",
        "98102": "Capitol Hill / Eastlake",
        "98103": "Fremont / Green Lake / Wallingford",
        "98104": "Pioneer Square / International District",
        "98105": "University District / Laurelhurst",
        "98106": "Delridge / South Park",
        "98107": "Ballard",
        "98108": "Georgetown / South Park",
        "98109": "South Lake Union / Queen Anne",
        "98111": "Downtown",
        "98112": "Capitol Hill / Madison Park",
        "98115": "Ravenna / Wedgwood",
        "98116": "West Seattle",
        "98117": "Ballard / Crown Hill",
        "98118": "Columbia City / Rainier Valley",
        "98119": "Queen Anne / Magnolia",
        "98121": "Belltown",
        "98122": "Capitol Hill / Central District",
        "98124": "Downtown",
        "98125": "Lake City / North Seattle",
        "98126": "West Seattle / Delridge",
        "98133": "Northgate / Bitter Lake",
        "98134": "SoDo",
        "98136": "West Seattle / Fauntleroy",
        "98144": "Mount Baker / Central District",
        "98154": "Downtown",
        "98164": "Downtown",
        "98174": "Downtown",
        "98177": "North Beach / Crown Hill",
        "98194": "Downtown",
        "98199": "Magnolia",
      };

      const ZIP_COORDS = {
        "98101": { lat: 47.6101, lon: -122.3344 },
        "98102": { lat: 47.634, lon: -122.322 },
        "98103": { lat: 47.671, lon: -122.343 },
        "98104": { lat: 47.602, lon: -122.328 },
        "98105": { lat: 47.661, lon: -122.3 },
        "98106": { lat: 47.536, lon: -122.356 },
        "98107": { lat: 47.669, lon: -122.383 },
        "98108": { lat: 47.547, lon: -122.322 },
        "98109": { lat: 47.632, lon: -122.346 },
        "98111": { lat: 47.609, lon: -122.334 },
        "98112": { lat: 47.629, lon: -122.298 },
        "98115": { lat: 47.684, lon: -122.296 },
        "98116": { lat: 47.576, lon: -122.4 },
        "98117": { lat: 47.687, lon: -122.381 },
        "98118": { lat: 47.54, lon: -122.275 },
        "98119": { lat: 47.638, lon: -122.369 },
        "98121": { lat: 47.615, lon: -122.349 },
        "98122": { lat: 47.611, lon: -122.305 },
        "98124": { lat: 47.605, lon: -122.334 },
        "98125": { lat: 47.717, lon: -122.304 },
        "98126": { lat: 47.553, lon: -122.374 },
        "98133": { lat: 47.732, lon: -122.344 },
        "98134": { lat: 47.579, lon: -122.326 },
        "98136": { lat: 47.54, lon: -122.39 },
        "98144": { lat: 47.586, lon: -122.302 },
        "98154": { lat: 47.606, lon: -122.334 },
        "98164": { lat: 47.604, lon: -122.329 },
        "98174": { lat: 47.604, lon: -122.33 },
        "98177": { lat: 47.742, lon: -122.375 },
        "98194": { lat: 47.607, lon: -122.332 },
        "98199": { lat: 47.648, lon: -122.397 },
      };

      const state = {
        rows: [],
        baseRows: [],
        filteredRows: [],
        geo: {
          map: null,
          layer: null,
          rows: [],
          neighborhoodRows: [],
          selectedPropertyKeys: [],
          viewportFilter: false,
          mapBounds: null,
        },
        recordSort: {
          key: "saleDate",
          dir: "desc",
        },
        recordMobileExpanded: null,
        flags: {
          projection: false,
        },
        interactions: {
          month: null,
          neighborhood: null,
          type: null,
          ratioBucket: null,
          hotMarket: null,
          mode: null,
          closeTier: null,
          psfTier: null,
        },
      };

      function esc(v) {
        return String(v ?? "")
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/\"/g, "&quot;")
          .replace(/'/g, "&#039;");
      }

      function toDate(value) {
        if (!value) return null;
        const raw = String(value).trim();
        if (!raw) return null;
        const iso = /^\d{4}-\d{2}-\d{2}$/;
        const d = iso.test(raw) ? new Date(`${raw}T00:00:00`) : new Date(raw);
        return Number.isNaN(d.getTime()) ? null : d;
      }

      function toIso(value) {
        const d = toDate(value);
        if (!d) return "";
        return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, "0")}-${String(d.getDate()).padStart(2, "0")}`;
      }

      function num(v) {
        if (v === null || v === undefined || v === "") return 0;
        const n = Number(String(v).replace(/[^0-9.-]/g, ""));
        return Number.isFinite(n) ? n : 0;
      }

      function formatMoney(v) {
        return Number(v || 0).toLocaleString("en-US", {
          style: "currency",
          currency: "USD",
          maximumFractionDigits: 0,
        });
      }

      function formatPct(v) {
        return `${(Number(v || 0) * 100).toFixed(1)}%`;
      }

      function domMetric(row) {
        if (row.mlsDOM > 0) return row.mlsDOM;
        if (row.daysToPending !== null && Number.isFinite(row.daysToPending) && row.daysToPending >= 0) return row.daysToPending;
        return null;
      }

      function domLabel(row) {
        const d = domMetric(row);
        return d === null ? "n/a" : `${d.toFixed(0)}d`;
      }

      function hotCategory(row) {
        if (row.isUltraHot) return "Ultra Hot";
        if (row.isHotMarket) return "Hot";
        return "Normal";
      }

      function hotCategoryBadge(row) {
        if (row.isUltraHot) return `<span class="hot-pill ultra">Ultra Hot</span>`;
        if (row.isHotMarket) return `<span class="hot-pill hot">Hot</span>`;
        return `<span class="hot-pill">Normal</span>`;
      }

      function closeDisplay(row) {
        if (row.closePrice > 0 && !row.isProjectionRow) return formatMoney(row.closePrice);
        if (row.projectedClosePrice > 0) return `~${formatMoney(row.projectedClosePrice)} proj`;
        return "Pending";
      }

      function deltaDisplay(row) {
        if (row.listPriceAtPending <= 0) return "n/a";
        if (row.delta || row.delta === 0) return formatMoney(row.delta);
        return "n/a";
      }

      function median(values) {
        if (!values.length) return 0;
        const sorted = [...values].sort((a, b) => a - b);
        const mid = Math.floor(sorted.length / 2);
        return sorted.length % 2 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
      }

      function quantile(values, q) {
        if (!values.length) return 0;
        const sorted = [...values].sort((a, b) => a - b);
        const pos = (sorted.length - 1) * q;
        const base = Math.floor(pos);
        const rest = pos - base;
        if (sorted[base + 1] !== undefined) {
          return sorted[base] + rest * (sorted[base + 1] - sorted[base]);
        }
        return sorted[base];
      }

      function monthKey(isoDate) {
        const d = toDate(isoDate);
        if (!d) return "Unknown";
        return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, "0")}`;
      }

      function monthLabel(month) {
        const m = String(month || "");
        if (!/^\d{4}-\d{2}$/.test(m)) return m || "Unknown";
        const [yy, mm] = m.split("-");
        const d = new Date(`${yy}-${mm}-01T00:00:00`);
        if (Number.isNaN(d.getTime())) return m;
        return d.toLocaleString("en-US", { month: "short", year: "numeric" });
      }

      function monthLabelCompact(month) {
        const m = String(month || "");
        if (!/^\d{4}-\d{2}$/.test(m)) return m || "Unknown";
        const [yy, mm] = m.split("-");
        const d = new Date(`${yy}-${mm}-01T00:00:00`);
        if (Number.isNaN(d.getTime())) return m;
        return `${d.toLocaleString("en-US", { month: "short" })} '${String(yy).slice(2)}`;
      }

      function daysBetween(a, b) {
        const d1 = toDate(a);
        const d2 = toDate(b);
        if (!d1 || !d2) return null;
        return Math.round((d2 - d1) / (1000 * 60 * 60 * 24));
      }

      function parseCsvLine(line) {
        const out = [];
        let cur = "";
        let inQuotes = false;
        for (let i = 0; i < line.length; i += 1) {
          const ch = line[i];
          if (ch === '"') {
            if (inQuotes && line[i + 1] === '"') {
              cur += '"';
              i += 1;
            } else {
              inQuotes = !inQuotes;
            }
          } else if (ch === "," && !inQuotes) {
            out.push(cur.trim());
            cur = "";
          } else {
            cur += ch;
          }
        }
        out.push(cur.trim());
        return out;
      }

      function parseCsv(text) {
        const lines = text.trim().split(/\r?\n/);
        if (lines.length < 2) return [];
        const headers = parseCsvLine(lines[0]);
        const idx = Object.fromEntries(headers.map((h, i) => [h, i]));

        const required = ["id", "address", "type", "closePrice"];
        const missing = required.filter((k) => idx[k] === undefined);
        if (missing.length) throw new Error(`Missing required columns: ${missing.join(", ")}`);

        return lines.slice(1).filter((line) => line.trim()).map((line, rowIndex) => {
          const cols = parseCsvLine(line);
          const pick = (name) => (idx[name] !== undefined ? (cols[idx[name]] || "").trim() : "");
          const latVal = num(pick("lat"));
          const lonVal = num(pick("lon"));
          const lat = Math.abs(latVal) > 1 ? latVal : null;
          const lon = Math.abs(lonVal) > 1 ? lonVal : null;
          return {
            dataMode: pick("dataMode"),
            id: pick("id"),
            address: pick("address"),
            addressSource: pick("addressSource"),
            major: pick("major"),
            minor: pick("minor"),
            parcelNbr: pick("parcelNbr"),
            neighborhood: pick("neighborhood"),
            type: pick("type"),
            typeCode: pick("typeCode"),
            listDate: pick("listDate"),
            pendingDate: pick("pendingDate"),
            saleDate: pick("saleDate"),
            listPriceAtPending: num(pick("listPriceAtPending")),
            closePrice: num(pick("closePrice")),
            assessedValue: num(pick("assessedValue")),
            beds: num(pick("beds")),
            baths: num(pick("baths")),
            sqft: num(pick("sqft")),
            yearBuilt: num(pick("yearBuilt")),
            zip: pick("zip"),
            lat,
            lon,
            sourceRowIndex: rowIndex + 1,
            mlsListDate: pick("mlsListDate"),
            mlsPendingDate: pick("mlsPendingDate"),
            mlsListPriceAtPending: num(pick("mlsListPriceAtPending")),
            mlsClosePrice: num(pick("mlsClosePrice")),
            mlsDOM: num(pick("mlsDOM")),
            mlsCDOM: num(pick("mlsCDOM")),
            hotMarketTag: pick("hotMarketTag"),
            saleToListRatio: num(pick("saleToListRatio")),
            saleToOriginalListRatio: num(pick("saleToOriginalListRatio")),
            bidUpAmount: num(pick("bidUpAmount")),
            bidUpPct: num(pick("bidUpPct")),
          };
        });
      }

      function titleCase(text) {
        return String(text || "")
          .toLowerCase()
          .replace(/\b\w/g, (m) => m.toUpperCase());
      }

      function inferMode(row) {
        if (row.dataMode) return row.dataMode;
        const hasMls = row.mlsListDate || row.mlsPendingDate || row.mlsListPriceAtPending || row.mlsClosePrice;
        return hasMls ? "MLS_ENRICHED" : "PUBLIC_PROXY";
      }

      function labelNeighborhood(rawNeighborhood, zip) {
        const raw = String(rawNeighborhood || "").trim();
        if (/[a-z]/i.test(raw)) return raw;
        const z = (String(zip || "").match(/[0-9]{5}/) || [])[0] || "";
        return ZIP_NEIGHBORHOOD[z] || "Seattle (Other)";
      }

      function labelType(rawType, typeCode) {
        const raw = String(rawType || "").trim();
        if (/[a-z]/i.test(raw)) {
          const pretty = /^[A-Z0-9\s,()\-]+$/.test(raw) ? titleCase(raw) : raw;
          const norm = pretty.toLowerCase();
          if (norm.includes("single family")) return "Single Family";
          if (norm.includes("condomini")) return "Condo";
          if (norm.includes("2-4 units")) return "Multi-Family (2-4 Units)";
          if (norm.includes("5+ units")) return "Multi-Family (5+ Units)";
          if (norm.includes("land")) return "Land";
          return pretty;
        }
        const code = String(num(typeCode || raw) || "");
        return TYPE_LABELS[code] || (code ? `Type ${code}` : "Unknown");
      }

      function mapPropertyKey(rowLike) {
        const id = String(rowLike.id || "").trim();
        const parcel = String(rowLike.parcelNbr || `${rowLike.major || ""}${rowLike.minor || ""}`).replace(/[^0-9]/g, "");
        const saleDate = String(rowLike.saleDate || rowLike.pendingDate || rowLike.listDate || "").trim();
        const addr = String(rowLike.address || "").trim().toUpperCase();
        const idx = String(rowLike.sourceRowIndex || "").trim();
        return [id, parcel, saleDate, addr, idx].join("|");
      }

      function normalizeForMatch(v) {
        return String(v || "").toLowerCase().replace(/[^a-z0-9]+/g, " ").trim();
      }

      function findDefaultSingleFamilyLabel() {
        const options = [...document.getElementById("fType").options].map((opt) => opt.value);
        const normalized = options.map((value) => ({ value, norm: normalizeForMatch(value) }));
        const exact = normalized.find((x) => x.norm === "single family");
        if (exact) return exact.value;
        const contains = normalized.find((x) => x.norm.includes("single family"));
        if (contains) return contains.value;
        const household = normalized.find((x) => x.norm.includes("household single family"));
        if (household) return household.value;
        return "All";
      }

      function applyDefaultFormFilters() {
        setNeighborhoodSelections([]);
        updateNeighborhoodSummary();
        document.getElementById("fType").value = findDefaultSingleFamilyLabel();
        document.getElementById("fMode").value = "All";
        document.getElementById("fScope").value = "all";
        const minEl = document.getElementById("fMinClose");
        const maxEl = document.getElementById("fMaxClose");
        const minBound = Number(minEl.min || 0);
        const maxBound = Number(maxEl.max || 3000000);
        const minDefault = Math.max(minBound, Math.min(DEFAULT_MIN_CLOSE, maxBound));
        const maxDefault = Math.max(minDefault, Math.min(DEFAULT_MAX_CLOSE, maxBound));
        minEl.value = String(minDefault);
        maxEl.value = String(maxDefault);
        syncPriceSliderPair();
        document.getElementById("fDateFrom").value = "";
        document.getElementById("fDateTo").value = "";
        state.flags.projection = false;
        const projectionToggle = document.getElementById("ffProjection");
        if (projectionToggle) projectionToggle.checked = false;
      }

      function normalizeRow(source) {
        const dataMode = inferMode(source);
        const saleDate = source.saleDate || source.pendingDate || source.listDate || "";
        const listDate = source.mlsListDate || source.listDate || "";
        const pendingDate = source.mlsPendingDate || source.pendingDate || "";

        const closePrice = num(source.mlsClosePrice || source.closePrice);
        const assessedValue = num(source.assessedValue);
        const listPriceAtPending = num(source.mlsListPriceAtPending || source.listPriceAtPending || closePrice);

        const daysToPending = daysBetween(listDate, pendingDate);
        const mlsDOM = num(source.mlsDOM);
        const mlsCDOM = num(source.mlsCDOM);
        const saleToList = num(source.saleToListRatio) || (listPriceAtPending > 0 ? (closePrice / listPriceAtPending) : 0);
        const delta = num(source.bidUpAmount) || (closePrice - listPriceAtPending);
        const deltaPct = num(source.bidUpPct) || (listPriceAtPending > 0 ? delta / listPriceAtPending : 0);
        const tagRaw = String(source.hotMarketTag || "").toUpperCase();
        const ultraByTag = /ULTRA[_\s]?HOT/.test(tagRaw);
        const hotByTag = /HOT_MARKET/.test(tagRaw) || ultraByTag;
        const ultraByDom = mlsDOM > 0 && mlsDOM <= 5;
        const ultraByPending = daysToPending !== null && daysToPending <= 5;
        const hotByDom = mlsDOM > 0 && mlsDOM <= 10;
        const hotByPending = daysToPending !== null && daysToPending <= 10;
        const isUltraHot = ultraByTag || ultraByDom || ultraByPending;
        const isHotMarket = isUltraHot || hotByTag || hotByDom || hotByPending;
        const sqft = num(source.sqft);
        const pricePerSqft = sqft > 0 ? closePrice / sqft : 0;
        const zipCoord = ZIP_COORDS[zip5(source.zip)];
        const mapLat = Number.isFinite(source.lat) ? source.lat : (zipCoord ? zipCoord.lat : null);
        const mapLon = Number.isFinite(source.lon) ? source.lon : (zipCoord ? zipCoord.lon : null);
        const hasActualClose = closePrice > 0 && !!toIso(saleDate);
        const effectiveDate = toIso(saleDate || pendingDate || listDate);

        return {
          ...source,
          mapPropertyKey: mapPropertyKey(source),
          dataMode,
          typeLabel: labelType(source.type, source.typeCode),
          neighborhoodLabel: labelNeighborhood(source.neighborhood, source.zip),
          saleDate: toIso(saleDate),
          listDate: toIso(listDate),
          pendingDate: toIso(pendingDate),
          effectiveDate,
          hasActualClose,
          isProjectionRow: false,
          projectedClosePrice: 0,
          projectedCloseLow: 0,
          projectedCloseHigh: 0,
          projectionBasisCount: 0,
          closePrice,
          assessedValue,
          listPriceAtPending,
          mlsDOM,
          mlsCDOM,
          beds: num(source.beds),
          baths: num(source.baths),
          sqft,
          yearBuilt: num(source.yearBuilt),
          daysToPending,
          saleToList,
          delta,
          deltaPct,
          hotMarketTag: isUltraHot ? "ULTRA_HOT_<=5D" : (isHotMarket ? "HOT_MARKET_<=10D" : ""),
          isUltraHot,
          isHotMarket,
          pricePerSqft,
          mapLat,
          mapLon,
        };
      }

      function getSelectedNeighborhoods() {
        return [...document.querySelectorAll("#fNeighborhoodOptions input[type='checkbox']:checked")]
          .map((cb) => cb.value);
      }

      function setNeighborhoodSelections(values) {
        const selected = new Set(values || []);
        document.querySelectorAll("#fNeighborhoodOptions input[type='checkbox']").forEach((cb) => {
          cb.checked = selected.has(cb.value);
        });
      }

      function updateNeighborhoodSummary() {
        const selected = getSelectedNeighborhoods();
        const summary = document.getElementById("fNeighborhoodSummary");
        if (!selected.length) {
          summary.textContent = "All neighborhoods";
          return;
        }
        if (selected.length === 1) {
          summary.textContent = selected[0];
          return;
        }
        summary.textContent = `${selected.length} neighborhoods selected`;
      }

      function syncPriceSliderPair(changedId) {
        const minEl = document.getElementById("fMinClose");
        const maxEl = document.getElementById("fMaxClose");
        let minVal = Number(minEl.value || PRICE_SLIDER_MIN);
        let maxVal = Number(maxEl.value || PRICE_SLIDER_CAP);
        minVal = Math.max(PRICE_SLIDER_MIN, Math.min(minVal, PRICE_SLIDER_CAP));
        maxVal = Math.max(PRICE_SLIDER_MIN, Math.min(maxVal, PRICE_SLIDER_CAP));
        if (minVal > maxVal) {
          if (changedId === "fMinClose") {
            maxVal = minVal;
          } else {
            minVal = maxVal;
          }
        }
        minEl.value = String(minVal);
        maxEl.value = String(maxVal);
        document.getElementById("fMinCloseValue").textContent = formatMoney(minVal);
        document.getElementById("fMaxCloseValue").textContent = maxVal >= PRICE_SLIDER_CAP
          ? "No max"
          : formatMoney(maxVal);
      }

      function configurePriceSliders() {
        const minEl = document.getElementById("fMinClose");
        const maxEl = document.getElementById("fMaxClose");
        const minCurrent = Number(minEl.value || DEFAULT_MIN_CLOSE);
        const maxCurrent = Number(maxEl.value || DEFAULT_MAX_CLOSE);

        [minEl, maxEl].forEach((el) => {
          el.min = String(PRICE_SLIDER_MIN);
          el.max = String(PRICE_SLIDER_CAP);
          el.step = String(PRICE_SLIDER_STEP);
        });

        const nextMin = Math.max(PRICE_SLIDER_MIN, Math.min(minCurrent, PRICE_SLIDER_CAP));
        const nextMax = Math.max(nextMin, Math.min(maxCurrent, PRICE_SLIDER_CAP));
        minEl.value = String(nextMin);
        maxEl.value = String(nextMax);
        syncPriceSliderPair();
      }

      function uniqueValues(rows, key) {
        return ["All", ...Array.from(new Set(rows.map((r) => r[key]).filter(Boolean))).sort()];
      }

      function refreshSelectOptions() {
        const normalized = state.rows.map(normalizeRow);
        const neighborhoods = Array.from(new Set(normalized.map((r) => r.neighborhoodLabel).filter(Boolean))).sort();
        const types = uniqueValues(normalized, "typeLabel");

        const nWrap = document.getElementById("fNeighborhoodOptions");
        const tSelect = document.getElementById("fType");

        const currentN = new Set(getSelectedNeighborhoods());
        const currentT = tSelect.value || "All";

        nWrap.innerHTML = neighborhoods.length
          ? neighborhoods.map((v) => {
              const checked = currentN.has(v) ? "checked" : "";
              return `<label class="multi-opt"><input type="checkbox" value="${esc(v)}" ${checked} /><span>${esc(v)}</span></label>`;
            }).join("")
          : `<div class="note">No neighborhoods in dataset.</div>`;
        tSelect.innerHTML = types.map((v) => `<option value="${esc(v)}">${esc(v)}</option>`).join("");

        tSelect.value = types.includes(currentT) ? currentT : "All";
        updateNeighborhoodSummary();
        configurePriceSliders();
      }

      function readFormFilters() {
        const maxRaw = Number(document.getElementById("fMaxClose").value || PRICE_SLIDER_CAP);
        return {
          neighborhoods: getSelectedNeighborhoods(),
          type: document.getElementById("fType").value,
          mode: document.getElementById("fMode").value,
          scope: document.getElementById("fScope").value,
          minClose: Number(document.getElementById("fMinClose").value || PRICE_SLIDER_MIN),
          maxClose: maxRaw >= PRICE_SLIDER_CAP ? null : maxRaw,
          dateFrom: document.getElementById("fDateFrom").value,
          dateTo: document.getElementById("fDateTo").value,
        };
      }

      function computeBaseRows() {
        const f = readFormFilters();
        let rows = state.rows.map(normalizeRow).filter((r) => r.closePrice > 0 && !!r.saleDate);

        if (f.neighborhoods.length) rows = rows.filter((r) => f.neighborhoods.includes(r.neighborhoodLabel));
        if (f.type !== "All") rows = rows.filter((r) => r.typeLabel === f.type);
        if (f.mode !== "All") rows = rows.filter((r) => r.dataMode === f.mode);
        if (f.minClose) rows = rows.filter((r) => r.closePrice >= f.minClose);
        if (f.maxClose !== null) rows = rows.filter((r) => r.closePrice <= f.maxClose);
        if (f.dateFrom) rows = rows.filter((r) => r.saleDate >= f.dateFrom);
        if (f.dateTo) rows = rows.filter((r) => r.saleDate <= f.dateTo);

        if (f.scope === "hot10") {
          rows = rows.filter((r) => r.dataMode === "MLS_ENRICHED" && r.isHotMarket);
        }
        if (f.scope === "ultra5") {
          rows = rows.filter((r) => r.dataMode === "MLS_ENRICHED" && r.isUltraHot);
        }

        return rows;
      }

      function computeProjectedPendingRows(referenceRows, stats) {
        if (!state.flags.projection) return [];
        const f = readFormFilters();
        if (f.mode === "PUBLIC_PROXY") return [];

        const compSource = referenceRows
          .filter((r) => r.hasActualClose && r.listPriceAtPending > 0 && r.saleToList > 0);
        if (!compSource.length) return [];

        const existing = new Set(referenceRows.map((r) => r.mapPropertyKey));
        let pendingRows = state.rows
          .map(normalizeRow)
          .filter((r) => r.dataMode === "MLS_ENRICHED" && !r.hasActualClose && r.listPriceAtPending > 0)
          .filter((r) => !existing.has(r.mapPropertyKey));

        if (f.neighborhoods.length) pendingRows = pendingRows.filter((r) => f.neighborhoods.includes(r.neighborhoodLabel));
        if (f.type !== "All") pendingRows = pendingRows.filter((r) => r.typeLabel === f.type);
        if (f.mode !== "All") pendingRows = pendingRows.filter((r) => r.dataMode === f.mode);
        if (f.minClose) pendingRows = pendingRows.filter((r) => r.listPriceAtPending >= f.minClose);
        if (f.maxClose !== null) pendingRows = pendingRows.filter((r) => r.listPriceAtPending <= f.maxClose);
        if (f.dateFrom) pendingRows = pendingRows.filter((r) => r.effectiveDate >= f.dateFrom);
        if (f.dateTo) pendingRows = pendingRows.filter((r) => r.effectiveDate <= f.dateTo);
        if (f.scope === "hot10") pendingRows = pendingRows.filter((r) => r.isHotMarket);
        if (f.scope === "ultra5") pendingRows = pendingRows.filter((r) => r.isUltraHot);

        const projected = pendingRows.map((r) => {
          let localComps = compSource.filter((c) => c.typeLabel === r.typeLabel && c.neighborhoodLabel === r.neighborhoodLabel);
          if (localComps.length < 6) localComps = compSource.filter((c) => c.typeLabel === r.typeLabel);
          if (localComps.length < 6) localComps = compSource;

          const ratios = localComps.map((c) => c.saleToList).filter((v) => v > 0);
          const ratioMed = ratios.length ? median(ratios) : 1;
          const ratioLow = ratios.length ? quantile(ratios, 0.25) : ratioMed;
          const ratioHigh = ratios.length ? quantile(ratios, 0.75) : ratioMed;
          const projectedClosePrice = Math.round(r.listPriceAtPending * ratioMed);
          const projectedCloseLow = Math.round(r.listPriceAtPending * ratioLow);
          const projectedCloseHigh = Math.round(r.listPriceAtPending * ratioHigh);
          const projectedDelta = projectedClosePrice - r.listPriceAtPending;
          const projectedPsf = r.sqft > 0 ? projectedClosePrice / r.sqft : 0;

          return {
            ...r,
            isProjectionRow: true,
            saleDate: r.pendingDate || r.listDate || r.saleDate,
            effectiveDate: r.pendingDate || r.listDate || r.effectiveDate,
            closePrice: projectedClosePrice,
            projectedClosePrice,
            projectedCloseLow,
            projectedCloseHigh,
            projectionBasisCount: localComps.length,
            saleToList: ratioMed,
            delta: projectedDelta,
            deltaPct: r.listPriceAtPending > 0 ? (projectedDelta / r.listPriceAtPending) : 0,
            pricePerSqft: projectedPsf,
          };
        });

        return applyInteractions(projected, stats);
      }

      function computeBaseStats(rows) {
        return {
          medianClose: median(rows.map((r) => r.closePrice)),
          medianPsf: median(rows.filter((r) => r.pricePerSqft > 0).map((r) => r.pricePerSqft)),
        };
      }

      function inRatioBucket(value, key) {
        if (key === "lt095") return value > 0 && value < 0.95;
        if (key === "095to100") return value >= 0.95 && value < 1.0;
        if (key === "100to105") return value >= 1.0 && value <= 1.05;
        if (key === "gt105") return value > 1.05;
        if (key === "gt100") return value > 1.0;
        return true;
      }

      function rowInViewport(row, bounds) {
        if (!bounds) return true;
        if (!Number.isFinite(row.mapLat) || !Number.isFinite(row.mapLon)) return false;
        const inLat = row.mapLat >= bounds.south && row.mapLat <= bounds.north;
        const inLon = row.mapLon >= bounds.west && row.mapLon <= bounds.east;
        return inLat && inLon;
      }

      function applyInteractions(baseRows, stats) {
        const i = state.interactions;
        const selectedMapKeys = state.geo.selectedPropertyKeys;
        const viewportFilterActive = state.geo.viewportFilter && !!state.geo.mapBounds;
        return baseRows.filter((r) => {
          if (selectedMapKeys.length && !selectedMapKeys.includes(r.mapPropertyKey)) return false;
          if (viewportFilterActive && !rowInViewport(r, state.geo.mapBounds)) return false;
          if (i.month && monthKey(r.saleDate) !== i.month) return false;
          if (i.neighborhood && r.neighborhoodLabel !== i.neighborhood) return false;
          if (i.type && r.typeLabel !== i.type) return false;
          if (i.mode && r.dataMode !== i.mode) return false;
          if (i.ratioBucket && !inRatioBucket(r.saleToList, i.ratioBucket)) return false;
          if (i.hotMarket === "hot" && !r.isHotMarket) return false;
          if (i.hotMarket === "ultra" && !r.isUltraHot) return false;
          if (i.closeTier === "aboveMedian" && r.closePrice < stats.medianClose) return false;
          if (i.psfTier === "aboveMedian") {
            if (r.pricePerSqft <= 0 || r.pricePerSqft < stats.medianPsf) return false;
          }
          return true;
        });
      }

      function interactionLabel(key, value) {
        const titles = {
          month: "Month",
          neighborhood: "Neighborhood",
          type: "Type",
          ratioBucket: "Sale/List",
          hotMarket: "Market Speed",
          mode: "Mode",
          closeTier: "Close Price",
          psfTier: "Price/SqFt",
        };
        const values = {
          lt095: "< 0.95x",
          "095to100": "0.95x - 1.00x",
          "100to105": "1.00x - 1.05x",
          gt105: "> 1.05x",
          gt100: "> 1.00x",
          aboveMedian: "Above Median",
          hot: "Hot Market (<=10d)",
          ultra: "Ultra Hot (<=5d)",
        };
        return `${titles[key] || key}: ${values[value] || value}`;
      }

      function renderChips() {
        const entries = Object.entries(state.interactions).filter(([, v]) => v);
        const el = document.getElementById("activeChips");
        const mapSelected = state.geo.selectedPropertyKeys.length;
        const viewportChip = state.geo.viewportFilter && state.geo.mapBounds;
        const projectionChip = state.flags.projection;
        if (!entries.length && !mapSelected && !viewportChip && !projectionChip) {
          el.innerHTML = `<span class="chip">No cross-filters active</span>`;
          return;
        }
        const chips = entries.map(([k, v]) => {
          return `<span class="chip">${esc(interactionLabel(k, v))}<button type="button" data-clear-interaction="${esc(k)}">x</button></span>`;
        });
        if (mapSelected) {
          chips.push(`<span class="chip">Map Properties: ${mapSelected}<button type="button" data-clear-map-selection="1">x</button></span>`);
        }
        if (viewportChip) {
          chips.push(`<span class="chip">Map Viewport<button type="button" data-clear-viewport-filter="1">x</button></span>`);
        }
        if (projectionChip) {
          chips.push(`<span class="chip">Feature: Pending Projections<button type="button" data-clear-flag="projection">x</button></span>`);
        }
        el.innerHTML = chips.join("");
      }

      function renderSummary(filtered, baseRows, projectedCount = 0) {
        const pub = filtered.filter((r) => r.dataMode === "PUBLIC_PROXY").length;
        const mls = (filtered.length - pub) + projectedCount;
        const projectionText = state.flags.projection ? ` | Pending Projections: ${projectedCount}` : "";
        document.getElementById("filterSummary").textContent =
          `Base rows: ${baseRows.length} | Current slice: ${filtered.length + projectedCount} | Public Proxy: ${pub} | MLS Enriched: ${mls}${projectionText}`;
      }

      function renderKpis(rows, stats) {
        const ratios = rows.filter((r) => r.saleToList > 0).map((r) => r.saleToList);
        const psf = rows.filter((r) => r.pricePerSqft > 0).map((r) => r.pricePerSqft);
        const mlsPending = rows.filter((r) => r.dataMode === "MLS_ENRICHED" && r.daysToPending !== null).map((r) => r.daysToPending);
        const mlsDom = rows.filter((r) => r.dataMode === "MLS_ENRICHED" && r.mlsDOM > 0).map((r) => r.mlsDOM);

        document.getElementById("kSales").textContent = rows.length;
        document.getElementById("kMedianClose").textContent = formatMoney(median(rows.map((r) => r.closePrice)));
        document.getElementById("kMedianSA").textContent = `${median(ratios).toFixed(2)}x`;
        const above = ratios.length ? (ratios.filter((v) => v > 1).length / ratios.length) * 100 : 0;
        document.getElementById("kAboveAssessed").textContent = `${above.toFixed(1)}%`;
        document.getElementById("kPsf").textContent = formatMoney(median(psf));
        document.getElementById("kPendingDays").textContent = mlsDom.length
          ? `${median(mlsDom).toFixed(0)} days`
          : (mlsPending.length ? `${median(mlsPending).toFixed(0)} days` : "n/a");

        document.querySelectorAll(".kbtn").forEach((b) => b.classList.remove("active"));
        if (state.interactions.closeTier === "aboveMedian") document.querySelector('[data-kpi-action="closeTier"]').classList.add("active");
        if (state.interactions.ratioBucket === "100to105") document.querySelector('[data-kpi-action="ratioMid"]').classList.add("active");
        if (state.interactions.ratioBucket === "gt100") document.querySelector('[data-kpi-action="ratioGt1"]').classList.add("active");
        if (state.interactions.psfTier === "aboveMedian") document.querySelector('[data-kpi-action="psfTier"]').classList.add("active");
        if (state.interactions.mode === "MLS_ENRICHED") document.querySelector('[data-kpi-action="mlsOnly"]').classList.add("active");
      }

      function renderInsights(rows) {
        const el = document.getElementById("insights");
        if (!rows.length) {
          el.innerHTML = `<li>No rows match current filters. Widen criteria or clear cross-filters.</li>`;
          return;
        }

        const ratios = rows.filter((r) => r.saleToList > 0).map((r) => r.saleToList);
        const overShare = ratios.length ? (ratios.filter((v) => v > 1).length / ratios.length) * 100 : 0;

        const byNeighborhood = {};
        rows.forEach((r) => { byNeighborhood[r.neighborhoodLabel] = (byNeighborhood[r.neighborhoodLabel] || 0) + 1; });
        const topNeighborhood = Object.entries(byNeighborhood).sort((a, b) => b[1] - a[1])[0];

        const byMonth = {};
        rows.forEach((r) => {
          const m = monthKey(r.saleDate);
          byMonth[m] = (byMonth[m] || 0) + 1;
        });
        const topMonth = Object.entries(byMonth).sort((a, b) => b[1] - a[1])[0];

        const lines = [
          `Median close price is ${formatMoney(median(rows.map((r) => r.closePrice)))} across ${rows.length} homes in this slice.`,
          `${overShare.toFixed(1)}% of homes closed above list-at-pending (median Sale/List ${median(ratios).toFixed(2)}x).`,
          `Highest activity is ${topNeighborhood ? topNeighborhood[0] : "n/a"} (${topNeighborhood ? topNeighborhood[1] : 0} sales).`,
          `Most active month is ${topMonth ? monthLabel(topMonth[0]) : "n/a"} (${topMonth ? topMonth[1] : 0} sales).`,
        ];

        const mlsRows = rows.filter((r) => r.dataMode === "MLS_ENRICHED" && r.daysToPending !== null);
        if (mlsRows.length) {
          lines.push(`MLS-enriched subset median days-to-pending: ${median(mlsRows.map((r) => r.daysToPending)).toFixed(0)} days.`);
        } else {
          lines.push("This slice currently uses public-record timing only. MLS timeline fields can be layered in when available.");
        }

        lines.push("Color scales cap outlier influence at robust percentile bounds (5th-95th).\n");
        el.innerHTML = lines.map((line) => `<li>${esc(line)}</li>`).join("");
      }

      function renderColumnChart(containerId, items, valueFn, labelFn, tailFn, warm) {
        const container = document.getElementById(containerId);
        if (!items.length) {
          container.innerHTML = `<div class="note">No rows for current filters.</div>`;
          return;
        }

        const vals = items.map((i) => valueFn(i));
        const qLow = quantile(vals, 0.05);
        const qHigh = quantile(vals, 0.95);
        const minVal = Math.min(...vals);
        const maxVal = Math.max(...vals);
        const low = Number.isFinite(qLow) ? qLow : minVal;
        const high = Number.isFinite(qHigh) ? qHigh : maxVal;
        const span = Math.max(high - low, 1);

        const topLabel = tailFn({ v: high, raw: maxVal, kind: "top" });
        const midLabel = tailFn({ v: low + span / 2, raw: (minVal + maxVal) / 2, kind: "mid" });
        const lowLabel = tailFn({ v: low, raw: minVal, kind: "low" });

        const bars = items.map((item) => {
          const raw = valueFn(item);
          const clamped = Math.max(low, Math.min(high, raw));
          const norm = (clamped - low) / span;
          const height = 12 + (norm * 88);
          const active = state.interactions.month === item.month;
          return `
            <button class="vbar ${active ? "active" : ""}" data-set-interaction="month" data-set-value="${esc(item.month)}" type="button">
              <span class="vbar-track"><span class="vbar-fill ${warm ? "warm" : ""}" style="height:${height}%"></span></span>
              <span class="vbar-month">${esc(labelFn(item))}</span>
              <span class="vbar-value">${esc(tailFn({ v: raw, raw, kind: "point" }))}</span>
            </button>
          `;
        }).join("");

        container.innerHTML = `
          <div class="vchart">
            <div class="y-axis">
              <span>${esc(topLabel)}</span>
              <span>${esc(midLabel)}</span>
              <span>${esc(lowLabel)}</span>
            </div>
            <div class="plot" style="--cols:${items.length}">${bars}</div>
          </div>
        `;
      }

      function renderCharts(rows) {
        const volume = {};
        rows.forEach((r) => {
          const m = monthKey(r.saleDate);
          if (!volume[m]) volume[m] = { month: m, count: 0 };
          volume[m].count += 1;
        });
        const volumeRows = Object.values(volume).sort((a, b) => a.month.localeCompare(b.month));
        renderColumnChart(
          "chartVolume",
          volumeRows,
          (x) => x.count,
          (x) => monthLabelCompact(x.month),
          (x) => `${Math.round(x.v).toLocaleString("en-US")} sales`,
          false
        );

        const price = {};
        rows.forEach((r) => {
          const m = monthKey(r.saleDate);
          if (!price[m]) price[m] = [];
          price[m].push(r.closePrice);
        });
        const priceRows = Object.entries(price)
          .map(([month, vals]) => ({ month, medianPrice: median(vals) }))
          .sort((a, b) => a.month.localeCompare(b.month));
        renderColumnChart(
          "chartMedian",
          priceRows,
          (x) => x.medianPrice,
          (x) => monthLabelCompact(x.month),
          (x) => formatMoney(x.v),
          true
        );
      }

      function renderRatioRows(rows) {
        const tbody = document.getElementById("ratioRows");
        if (!rows.length) {
          tbody.innerHTML = `<tr><td colspan="4">No rows for current filters.</td></tr>`;
          return;
        }

        const buckets = [
          { key: "lt095", label: "< 0.95x" },
          { key: "095to100", label: "0.95x - 1.00x" },
          { key: "100to105", label: "1.00x - 1.05x" },
          { key: "gt105", label: "> 1.05x" },
        ];

        const total = rows.length;
        tbody.innerHTML = buckets.map((b) => {
          const set = rows.filter((r) => inRatioBucket(r.saleToList, b.key));
          const share = total ? ((set.length / total) * 100).toFixed(1) : "0.0";
          const active = state.interactions.ratioBucket === b.key;
          return `
            <tr class="clickable ${active ? "active" : ""}" data-set-interaction="ratioBucket" data-set-value="${esc(b.key)}">
              <td>${esc(b.label)}</td>
              <td>${set.length}</td>
              <td>${share}%</td>
              <td>${formatMoney(median(set.map((r) => r.closePrice)))}</td>
            </tr>
          `;
        }).join("");
      }

      function renderRankRows(rows) {
        const tbody = document.getElementById("rankRows");
        if (!rows.length) {
          tbody.innerHTML = `<tr><td colspan="4">No rows for current filters.</td></tr>`;
          return;
        }

        const grouped = {};
        rows.forEach((r) => {
          if (!grouped[r.neighborhoodLabel]) grouped[r.neighborhoodLabel] = [];
          grouped[r.neighborhoodLabel].push(r);
        });

        const rank = Object.entries(grouped)
          .map(([name, set]) => ({
            name,
            count: set.length,
            medianClose: median(set.map((r) => r.closePrice)),
            medianRatio: median(set.filter((r) => r.saleToList > 0).map((r) => r.saleToList)),
          }))
          .sort((a, b) => (b.count - a.count) || (b.medianClose - a.medianClose))
          .slice(0, 18);

        tbody.innerHTML = rank.map((r) => {
          const active = state.interactions.neighborhood === r.name;
          return `
            <tr class="clickable ${active ? "active" : ""}" data-set-interaction="neighborhood" data-set-value="${esc(r.name)}">
              <td>${esc(r.name)}</td>
              <td>${r.count}</td>
              <td>${formatMoney(r.medianClose)}</td>
              <td>${r.medianRatio.toFixed(2)}x</td>
            </tr>
          `;
        }).join("");
      }

      function renderHotMarket(rows) {
        const shareEl = document.getElementById("hHotShare");
        const ultraShareEl = document.getElementById("hUltraShare");
        const medianRatioEl = document.getElementById("hMedianSL");
        const medianBidEl = document.getElementById("hMedianBid");
        const medianDomEl = document.getElementById("hMedianDOM");
        const tbody = document.getElementById("hotRows");
        if (!shareEl || !ultraShareEl || !medianRatioEl || !medianBidEl || !medianDomEl || !tbody) return;

        const mlsRows = rows.filter((r) => r.dataMode === "MLS_ENRICHED");
        const hotRows = mlsRows.filter((r) => r.isHotMarket);
        const ultraRows = mlsRows.filter((r) => r.isUltraHot);
        const share = mlsRows.length ? (hotRows.length / mlsRows.length) * 100 : 0;
        const ultraShare = mlsRows.length ? (ultraRows.length / mlsRows.length) * 100 : 0;
        shareEl.textContent = `${share.toFixed(1)}%`;
        ultraShareEl.textContent = `${ultraShare.toFixed(1)}%`;

        const ratios = hotRows.filter((r) => r.saleToList > 0).map((r) => r.saleToList);
        const bidUps = hotRows.map((r) => r.delta);
        const doms = hotRows
          .map((r) => (r.mlsDOM > 0 ? r.mlsDOM : r.daysToPending))
          .filter((v) => v !== null && Number.isFinite(v) && v >= 0);

        medianRatioEl.textContent = hotRows.length ? `${median(ratios).toFixed(2)}x` : "n/a";
        medianBidEl.textContent = hotRows.length ? formatMoney(median(bidUps)) : "n/a";
        medianDomEl.textContent = doms.length ? `${median(doms).toFixed(0)} days` : "n/a";

        if (!hotRows.length) {
          tbody.innerHTML = `<tr><td colspan="5">No hot-market MLS rows in this slice.</td></tr>`;
          return;
        }

        const grouped = {};
        hotRows.forEach((r) => {
          if (!grouped[r.neighborhoodLabel]) grouped[r.neighborhoodLabel] = [];
          grouped[r.neighborhoodLabel].push(r);
        });

        const rank = Object.entries(grouped)
          .map(([name, set]) => {
            const setDom = set
              .map((r) => (r.mlsDOM > 0 ? r.mlsDOM : r.daysToPending))
              .filter((v) => v !== null && Number.isFinite(v) && v >= 0);
            const setRatio = set.filter((r) => r.saleToList > 0).map((r) => r.saleToList);
            const above = setRatio.length ? (setRatio.filter((v) => v > 1).length / setRatio.length) * 100 : 0;
            return {
              name,
              count: set.length,
              medianDom: setDom.length ? median(setDom) : 0,
              medianRatio: setRatio.length ? median(setRatio) : 0,
              abovePct: above,
            };
          })
          .sort((a, b) => (b.count - a.count) || (a.medianDom - b.medianDom))
          .slice(0, 20);

        tbody.innerHTML = rank.map((r) => `
          <tr class="clickable" data-set-interaction="neighborhood" data-set-value="${esc(r.name)}">
            <td>${esc(r.name)}</td>
            <td>${r.count}</td>
            <td>${r.medianDom > 0 ? `${r.medianDom.toFixed(0)} days` : "n/a"}</td>
            <td>${r.medianRatio > 0 ? `${r.medianRatio.toFixed(2)}x` : "n/a"}</td>
            <td>${r.abovePct.toFixed(1)}%</td>
          </tr>
        `).join("");
      }

      function zip5(zip) {
        return (String(zip || "").match(/[0-9]{5}/) || [])[0] || "";
      }

      function buildGeoNeighborhoodRows(rows) {
        const grouped = {};
        let exactRows = 0;

        rows.forEach((r) => {
          const name = r.neighborhoodLabel || "Seattle (Other)";
          if (!grouped[name]) {
            grouped[name] = {
              name,
              count: 0,
              prices: [],
              listPrices: [],
              ratios: [],
              ratioAbove: 0,
              doms: [],
              hotCount: 0,
              ultraCount: 0,
              latSum: 0,
              lonSum: 0,
              coordCount: 0,
            };
          }
          const g = grouped[name];
          g.count += 1;
          g.prices.push(r.closePrice || 0);
          if (r.listPriceAtPending > 0) g.listPrices.push(r.listPriceAtPending);
          if (r.saleToList > 0) {
            g.ratios.push(r.saleToList);
            if (r.saleToList > 1) g.ratioAbove += 1;
          }
          const d = domMetric(r);
          if (d !== null) g.doms.push(d);
          if (r.isHotMarket) g.hotCount += 1;
          if (r.isUltraHot) g.ultraCount += 1;

          const hasExactCoord = Number.isFinite(r.lat) && Number.isFinite(r.lon);
          if (hasExactCoord) exactRows += 1;
          const coord = hasExactCoord
            ? { lat: r.lat, lon: r.lon }
            : ZIP_COORDS[zip5(r.zip)];
          if (coord) {
            g.latSum += coord.lat;
            g.lonSum += coord.lon;
            g.coordCount += 1;
          }
        });

        const geoRows = Object.values(grouped).map((g) => ({
          name: g.name,
          count: g.count,
          medianList: median(g.listPrices),
          medianClose: median(g.prices),
          medianDom: median(g.doms),
          medianRatio: median(g.ratios),
          aboveRatioShare: g.ratios.length ? (g.ratioAbove / g.ratios.length) : 0,
          hotShare: g.count ? (g.hotCount / g.count) : 0,
          ultraShare: g.count ? (g.ultraCount / g.count) : 0,
          lat: g.coordCount ? (g.latSum / g.coordCount) : null,
          lon: g.coordCount ? (g.lonSum / g.coordCount) : null,
        })).sort((a, b) => (b.count - a.count) || (b.medianClose - a.medianClose));

        return { geoRows, exactRows, totalRows: rows.length };
      }

      function geoRatioColor(norm) {
        const n = Math.max(0, Math.min(1, norm));
        const hue = Math.round(220 - (n * 165));
        return `hsl(${hue} 74% 56%)`;
      }

      function hash32(text) {
        let h = 2166136261;
        const s = String(text || "");
        for (let i = 0; i < s.length; i += 1) {
          h ^= s.charCodeAt(i);
          h = Math.imul(h, 16777619);
        }
        return h >>> 0;
      }

      function buildGeoDetailPoints(rows, zoom, bounds) {
        const groups = {};

        rows.forEach((r, idx) => {
          const exactCoord = (Number.isFinite(r.lat) && Number.isFinite(r.lon))
            ? { lat: r.lat, lon: r.lon }
            : null;
          if (!exactCoord) return;
          const scopeKey = `exact:${exactCoord.lat.toFixed(6)}:${exactCoord.lon.toFixed(6)}`;
          if (!groups[scopeKey]) groups[scopeKey] = { base: exactCoord, points: [] };
          groups[scopeKey].points.push({
            row: r,
            key: r.parcelNbr || r.id || `${r.address || "row"}|${r.saleDate || ""}|${idx}`,
          });
        });

        const out = [];
        Object.entries(groups).forEach(([scopeKey, g]) => {
          g.points.sort((a, b) => hash32(a.key) - hash32(b.key));
          const baseAngle = ((hash32(scopeKey) % 360) / 180) * Math.PI;
          const lonAdj = Math.max(Math.cos((g.base.lat * Math.PI) / 180), 0.35);
          const spiralStep = zoom >= 15 ? 0.00005 : 0.00008;

          g.points.forEach((entry, i) => {
            if (g.points.length === 1) {
              if (!bounds || bounds.contains([g.base.lat, g.base.lon])) {
                out.push({ row: entry.row, lat: g.base.lat, lon: g.base.lon, exact: true });
              }
              return;
            }
            const ring = i + 1;
            const radius = spiralStep * Math.sqrt(ring);
            const angle = baseAngle + (ring * 2.399963229728653);
            const lat = g.base.lat + (Math.cos(angle) * radius);
            const lon = g.base.lon + ((Math.sin(angle) * radius) / lonAdj);
            if (!bounds || bounds.contains([lat, lon])) out.push({ row: entry.row, lat, lon, exact: true });
          });
        });

        return out;
      }

      function drawGeoNeighborhoodBubbles(mapPoints, layer) {
        const maxCount = Math.max(...mapPoints.map((p) => p.count), 1);
        const ratioScale = seqScale(mapPoints.filter((p) => p.medianRatio > 0).map((p) => p.medianRatio));
        mapPoints.forEach((p) => {
          const size = Math.round(24 + ((p.count / maxCount) * 34));
          const color = geoRatioColor(p.medianRatio > 0 ? ratioScale(p.medianRatio) : 0.5);
          const active = state.interactions.neighborhood === p.name ? "active" : "";
          const icon = L.divIcon({
            className: "geo-marker-wrap",
            html: `<button class="geo-bubble ${active}" style="--b-size:${size}px;--b-color:${color}" type="button">${p.count}</button>`,
            iconSize: [size, size],
            iconAnchor: [size / 2, size / 2],
          });
          const marker = L.marker([p.lat, p.lon], { icon, keyboard: false });
          marker.on("click", () => setInteraction("neighborhood", p.name));
          marker.bindTooltip(
            `<b>${esc(p.name)}</b><br>${p.count} sales<br>${p.medianList > 0 ? formatMoney(p.medianList) : "n/a"} median list<br>${formatMoney(p.medianClose)} median sale<br>${p.medianDom > 0 ? `${p.medianDom.toFixed(0)}d` : "n/a"} median DOM<br>${formatPct(p.hotShare)} hot (${formatPct(p.ultraShare)} ultra)<br>${p.medianRatio > 0 ? `${p.medianRatio.toFixed(2)}x` : "n/a"} median S/List`,
            { direction: "top", className: "geo-tip", pane: "geoTooltipPane", offset: [0, -8], opacity: 0.98, sticky: true }
          );
          marker.addTo(layer);
        });
      }

      function geoTooltipHtml(row) {
        return `
          <div class="geo-tip-card">
            <div class="geo-tip-title">${esc(row.address || "Address unavailable")}</div>
            <div class="geo-tip-row"><span class="k">List@Pending</span><span class="v">${formatMoney(row.listPriceAtPending)}</span></div>
            <div class="geo-tip-row"><span class="k">Sale Price</span><span class="v">${closeDisplay(row)}</span></div>
            <div class="geo-tip-row"><span class="k">DOM</span><span class="v">${domLabel(row)}</span></div>
            <div class="geo-tip-row"><span class="k">Heat</span><span class="v">${hotCategory(row)}</span></div>
            <div class="geo-tip-row"><span class="k">Sale/List</span><span class="v">${row.saleToList > 0 ? `${row.saleToList.toFixed(2)}x` : "n/a"}</span></div>
          </div>
        `;
      }

      function geoPopupHtml(row, zUrl, countyUrl, isSelected) {
        const projectionLine = row.isProjectionRow && row.projectedCloseLow > 0 && row.projectedCloseHigh > 0
          ? `<br>Projected range: ${formatMoney(row.projectedCloseLow)} - ${formatMoney(row.projectedCloseHigh)}`
          : "";
        return `
          <b>${esc(row.address || "Address unavailable")}</b><br>
          List@Pending: ${formatMoney(row.listPriceAtPending)}<br>
          Sale: ${closeDisplay(row)}${projectionLine}<br>
          DOM: ${domLabel(row)} | ${hotCategory(row)}<br>
          ${row.saleToList > 0 ? `${row.saleToList.toFixed(2)}x Sale/List` : "n/a Sale/List"}<br>
          ${esc(row.neighborhoodLabel || "Seattle")} | ${esc(row.saleDate || row.pendingDate || "n/a")}<br>
          <a href="${esc(zUrl)}" target="_blank" rel="noopener noreferrer">Open Zillow &#8599;</a>${countyUrl ? ` | <a href="${esc(countyUrl)}" target="_blank" rel="noopener noreferrer">KC Record</a>` : ""}<br>
          <span style="font-size:11px;color:#1f6040;">Exact coordinate  click dot to ${isSelected ? "remove" : "add"} property filter</span>
        `;
      }

      function clearMapPropertySelection(skipRender = false) {
        state.geo.selectedPropertyKeys = [];
        if (!skipRender) renderAll();
      }

      function toggleMapPropertySelection(mapKey) {
        toggleMapPropertySelections([mapKey]);
      }

      function toggleMapPropertySelections(mapKeys) {
        const cleaned = [...new Set((mapKeys || []).filter(Boolean))];
        if (!cleaned.length) return;
        const set = new Set(state.geo.selectedPropertyKeys);
        const allSelected = cleaned.every((k) => set.has(k));
        if (allSelected) {
          cleaned.forEach((k) => set.delete(k));
        } else {
          cleaned.forEach((k) => set.add(k));
        }
        state.geo.selectedPropertyKeys = [...set];
        renderAll();
      }

      function renderGeoSelectedRows(rows) {
        const countEl = document.getElementById("geoSelectedCount");
        const tbody = document.getElementById("geoSelectedRows");
        const mobile = document.getElementById("geoSelectedMobile");
        if (!countEl || !tbody || !mobile) return;

        if (!state.geo.selectedPropertyKeys.length) {
          countEl.textContent = "0 selected";
          tbody.innerHTML = `<tr><td colspan="7">Click map dots to filter to specific properties.</td></tr>`;
          mobile.innerHTML = `<div class="note">Click map dots to filter to specific properties.</div>`;
          return;
        }

        const selectedSet = new Set(state.geo.selectedPropertyKeys);
        const selectedRows = rows.filter((r) => selectedSet.has(r.mapPropertyKey));
        countEl.textContent = `${selectedRows.length} selected`;
        if (!selectedRows.length) {
          tbody.innerHTML = `<tr><td colspan="7">No selected properties in current filter scope.</td></tr>`;
          mobile.innerHTML = `<div class="note">No selected properties in current filter scope.</div>`;
          return;
        }

        const sorted = selectedRows
          .slice()
          .sort((a, b) => (b.closePrice - a.closePrice) || String(a.address).localeCompare(String(b.address)))
          .slice(0, 40);
        tbody.innerHTML = sorted.map((r) => `
          <tr>
            <td><a class="address-link" href="${esc(zillowUrl(r))}" target="_blank" rel="noopener noreferrer">${esc(r.address || "Address unavailable")}<span class="ext-icon" aria-hidden="true">&#8599;</span></a></td>
            <td>${esc(r.neighborhoodLabel || "Seattle")}</td>
            <td>${formatMoney(r.listPriceAtPending)}</td>
            <td>${closeDisplay(r)}</td>
            <td>${domLabel(r)}</td>
            <td>${hotCategoryBadge(r)}</td>
            <td>${esc(r.saleDate || r.pendingDate || "n/a")}</td>
          </tr>
        `).join("");
        mobile.innerHTML = sorted.slice(0, 24).map((r) => `
          <article class="geo-mobile-card">
            <div class="v"><a class="address-link" href="${esc(zillowUrl(r))}" target="_blank" rel="noopener noreferrer">${esc(r.address || "Address unavailable")}<span class="ext-icon" aria-hidden="true">&#8599;</span></a></div>
            <div class="k">${esc(r.neighborhoodLabel || "Seattle")} | ${esc(r.saleDate || r.pendingDate || "n/a")}</div>
            <div class="v">List ${formatMoney(r.listPriceAtPending)} | Sale ${closeDisplay(r)}</div>
            <div class="k">${domLabel(r)} | ${hotCategory(r)}</div>
          </article>
        `).join("");
      }

      function drawGeoLayer(rows, neighborhoodRows) {
        const map = state.geo.map;
        const layer = state.geo.layer;
        if (!map || !layer) return;
        layer.clearLayers();

        const mapPoints = neighborhoodRows.filter((g) => Number.isFinite(g.lat) && Number.isFinite(g.lon));
        if (!mapPoints.length) return;

        const zoom = map.getZoom();
        const bounds = map.getBounds();
        const detailMode = zoom >= GEO_DETAIL_ZOOM;

        if (!detailMode) {
          drawGeoNeighborhoodBubbles(mapPoints, layer);
          return;
        }

        const paddedBounds = bounds.pad(0.35);
        const detailPoints = buildGeoDetailPoints(rows, zoom, paddedBounds);
        if (!detailPoints.length) {
          drawGeoNeighborhoodBubbles(mapPoints, layer);
          return;
        }
        if (!map.getPane("geoDetailPoints")) {
          map.createPane("geoDetailPoints");
          map.getPane("geoDetailPoints").style.zIndex = "650";
        }
        const rowRatioScale = seqScale(detailPoints
          .map((p) => p.row.saleToList)
          .filter((v) => v > 0));

        detailPoints.forEach(({ row: r, lat, lon }) => {
          const color = geoRatioColor(r.saleToList > 0 ? rowRatioScale(r.saleToList) : 0.5);
          const zUrl = zillowUrl(r);
          const countyUrl = countyRecordUrl(r);
          const isSelected = state.geo.selectedPropertyKeys.includes(r.mapPropertyKey);
          const marker = L.circleMarker([lat, lon], {
            pane: "geoDetailPoints",
            radius: (zoom >= 15 ? 8 : 10) + (isSelected ? 2 : 0),
            weight: isSelected ? 3 : 2,
            color: isSelected ? "#f9d26b" : "#0e2f1c",
            fillColor: color,
            fillOpacity: 0.97,
          });
          marker.bindTooltip(
            geoTooltipHtml(r),
            { direction: "top", className: "geo-tip", pane: "geoTooltipPane", offset: [0, -10], opacity: 0.98, sticky: true }
          );
          marker.bindPopup(
            geoPopupHtml(r, zUrl, countyUrl, isSelected),
            { maxWidth: 360 }
          );
          marker.on("click", () => toggleMapPropertySelection(r.mapPropertyKey));
          marker.addTo(layer);
        });
      }

      function ensureGeoMap() {
        const mapEl = document.getElementById("geoMap");
        if (!mapEl) return null;
        if (state.geo.map) return state.geo.map;
        if (!window.L) {
          mapEl.innerHTML = `<div class="note">Interactive map library unavailable.</div>`;
          return null;
        }

        mapEl.innerHTML = `<div id="geoCanvas"></div>`;
        const map = L.map("geoCanvas", {
          zoomControl: true,
          scrollWheelZoom: true,
          preferCanvas: true,
          minZoom: 10,
          maxZoom: 17,
        });
        map.createPane("geoTooltipPane");
        map.getPane("geoTooltipPane").style.zIndex = "760";
        map.getPane("geoTooltipPane").style.pointerEvents = "none";
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>',
        }).addTo(map);
        map.setView([47.6062, -122.3321], 11);
        const initBounds = map.getBounds();
        state.geo.mapBounds = {
          north: initBounds.getNorth(),
          south: initBounds.getSouth(),
          east: initBounds.getEast(),
          west: initBounds.getWest(),
        };
        state.geo.layer = L.layerGroup().addTo(map);
        map.on("zoomend moveend", () => {
          const b = map.getBounds();
          state.geo.mapBounds = {
            north: b.getNorth(),
            south: b.getSouth(),
            east: b.getEast(),
            west: b.getWest(),
          };
          if (state.geo.viewportFilter) {
            renderAll();
            return;
          }
          if (state.geo.rows.length) drawGeoLayer(state.geo.rows, state.geo.neighborhoodRows);
        });
        state.geo.map = map;
        return map;
      }

      function renderGeo(rows) {
        const mapEl = document.getElementById("geoMap");
        const tbody = document.getElementById("geoRows");
        const mobileInsights = document.getElementById("geoInsightsMobile");
        if (!mapEl || !tbody || !mobileInsights) return;
        const vpToggle = document.getElementById("geoViewportFilter");
        if (vpToggle) vpToggle.checked = !!state.geo.viewportFilter;
        renderGeoSelectedRows(rows);

        const built = buildGeoNeighborhoodRows(rows);
        const geoRows = built.geoRows;
        const mapPoints = geoRows.filter((g) => Number.isFinite(g.lat) && Number.isFinite(g.lon));

        const coverage = built.totalRows ? (built.exactRows / built.totalRows) : 0;
        document.getElementById("geoCount").textContent = String(geoRows.length);
        document.getElementById("geoCoverage").textContent = `${(coverage * 100).toFixed(1)}%`;
        const topPrice = geoRows.length ? geoRows.slice().sort((a, b) => b.medianClose - a.medianClose)[0] : null;
        const topRatio = geoRows.filter((g) => g.medianRatio > 0).sort((a, b) => b.medianRatio - a.medianRatio)[0];
        document.getElementById("geoTopPrice").textContent = topPrice ? `${topPrice.name} (${formatMoney(topPrice.medianClose)})` : "n/a";
        document.getElementById("geoTopRatio").textContent = topRatio ? `${topRatio.name} (${topRatio.medianRatio.toFixed(2)}x)` : "n/a";

        const map = ensureGeoMap();
        if (map && state.geo.viewportFilter) {
          const b = map.getBounds();
          state.geo.mapBounds = {
            north: b.getNorth(),
            south: b.getSouth(),
            east: b.getEast(),
            west: b.getWest(),
          };
        }
        state.geo.rows = rows;
        state.geo.neighborhoodRows = geoRows;
        if (!geoRows.length) {
          if (map && state.geo.layer) state.geo.layer.clearLayers();
          tbody.innerHTML = `<tr><td colspan="5">No rows for current filters.</td></tr>`;
          mobileInsights.innerHTML = `<div class="note">No neighborhoods for current filters.</div>`;
          return;
        }
        if (map && state.geo.layer) drawGeoLayer(rows, geoRows);

        tbody.innerHTML = geoRows.slice(0, 20).map((g) => {
          const active = state.interactions.neighborhood === g.name;
          return `
            <tr class="clickable ${active ? "active" : ""}" data-set-interaction="neighborhood" data-set-value="${esc(g.name)}">
              <td>${esc(g.name)}</td>
              <td>${g.count}</td>
              <td>${formatMoney(g.medianClose)}</td>
              <td>${g.medianRatio > 0 ? `${g.medianRatio.toFixed(2)}x` : "n/a"}</td>
              <td>${(g.aboveRatioShare * 100).toFixed(1)}%</td>
            </tr>
          `;
        }).join("");
        mobileInsights.innerHTML = geoRows.slice(0, 20).map((g) => {
          const active = state.interactions.neighborhood === g.name;
          return `
            <button class="geo-mobile-card ${active ? "active" : ""}" type="button" data-set-interaction="neighborhood" data-set-value="${esc(g.name)}">
              <div class="v">${esc(g.name)}</div>
              <div class="k">${g.count} sales | ${(g.aboveRatioShare * 100).toFixed(1)}% above 1.0x</div>
              <div class="v">${formatMoney(g.medianClose)} | ${g.medianRatio > 0 ? `${g.medianRatio.toFixed(2)}x` : "n/a"}</div>
            </button>
          `;
        }).join("");
      }

      function seqScale(values) {
        if (!values.length) return () => 0;
        const low = quantile(values, 0.05);
        const high = quantile(values, 0.95);
        const span = Math.max(high - low, 1);
        return (v) => {
          const clamped = Math.max(low, Math.min(high, v));
          return (clamped - low) / span;
        };
      }

      function divScale(values) {
        const abs = values.map((v) => Math.abs(v)).filter((v) => v > 0);
        if (!abs.length) return () => 0;
        const cap = Math.max(quantile(abs, 0.95), 1);
        return (v) => Math.max(-1, Math.min(1, v / cap));
      }

      function seqHeat(norm, color) {
        const pct = Math.round(Math.max(0, Math.min(1, norm)) * 100);
        return `background: linear-gradient(90deg, ${color} ${pct}%, rgba(255,255,255,0.03) ${pct}%);`;
      }

      function divHeat(norm) {
        const pct = Math.round(Math.max(0, Math.min(1, Math.abs(norm))) * 100);
        const color = norm >= 0 ? "rgba(61, 213, 157, 0.34)" : "rgba(230, 113, 140, 0.34)";
        return `background: linear-gradient(90deg, ${color} ${pct}%, rgba(255,255,255,0.03) ${pct}%);`;
      }

      function zillowUrl(row) {
        const raw = String(row.address || "").replace(/\s+/g, " ").trim();
        const core = raw.replace(/,\s*Seattle\b.*$/i, "").trim() || raw;
        const z = zip5(row.zip) || (String(raw).match(/\b[0-9]{5}\b/) || [])[0] || "";
        const full = `${core} Seattle WA ${z}`.trim();
        const slug = full
          .toLowerCase()
          .replace(/[^a-z0-9]+/g, "-")
          .replace(/^-+|-+$/g, "");
        return `https://www.zillow.com/homes/${slug}_rb/`;
      }

      function countyRecordUrl(row) {
        const p = String(row.parcelNbr || `${row.major || ""}${row.minor || ""}`)
          .replace(/[^0-9]/g, "");
        if (!p) return "";
        return `https://info.kingcounty.gov/Assessor/eRealProperty/Detail.aspx?ParcelNbr=${p}`;
      }

      function addressSourceBadgeHtml(addressSource) {
        const src = String(addressSource || "");
        if (src === "SITUS_PROXY") return "";
        if (src === "PARCEL_FALLBACK") return `<span class="addr-badge">Parcel</span>`;
        if (src.startsWith("MAILING")) return `<span class="addr-badge">Mailing</span>`;
        return `<span class="addr-badge">${esc(src || "Other")}</span>`;
      }

      function getRecordSortValue(row, key) {
        if (key === "address") return String(row.address || "");
        if (key === "neighborhood") return String(row.neighborhoodLabel || "");
        if (key === "type") return String(row.typeLabel || "");
        if (key === "beds") return Number(row.beds || 0);
        if (key === "baths") return Number(row.baths || 0);
        if (key === "sqft") return Number(row.sqft || 0);
        if (key === "saleDate") return String(row.saleDate || "");
        if (key === "closePrice") return Number(row.closePrice || 0);
        if (key === "listPriceAtPending") return Number(row.listPriceAtPending || 0);
        if (key === "domMetric") return Number(domMetric(row) ?? -1);
        if (key === "hotCategory") return String(hotCategory(row));
        if (key === "saleToList") return Number(row.saleToList || 0);
        if (key === "delta") return Number(row.delta || 0);
        if (key === "dataMode") return String(row.dataMode || "");
        return "";
      }

      function applyRecordSort(rows) {
        const { key, dir } = state.recordSort;
        const factor = dir === "asc" ? 1 : -1;
        return rows.slice().sort((a, b) => {
          const av = getRecordSortValue(a, key);
          const bv = getRecordSortValue(b, key);
          if (typeof av === "number" && typeof bv === "number") return (av - bv) * factor;
          return String(av).localeCompare(String(bv), undefined, { numeric: true, sensitivity: "base" }) * factor;
        });
      }

      function updateRecordSortHeaderUI() {
        document.querySelectorAll(".th-sort").forEach((btn) => {
          btn.classList.remove("active");
        });
        document.querySelectorAll("[data-sort-ind]").forEach((el) => {
          el.textContent = "";
        });
        const active = document.querySelector(`.th-sort[data-record-sort="${state.recordSort.key}"]`);
        if (active) active.classList.add("active");
        const ind = document.querySelector(`[data-sort-ind="${state.recordSort.key}"]`);
        if (ind) ind.textContent = state.recordSort.dir === "asc" ? "" : "";
      }

      function setRecordSort(key) {
        const textKeys = new Set(["address", "neighborhood", "type", "dataMode", "hotCategory"]);
        if (state.recordSort.key === key) {
          state.recordSort.dir = state.recordSort.dir === "asc" ? "desc" : "asc";
        } else {
          state.recordSort.key = key;
          state.recordSort.dir = textKeys.has(key) ? "asc" : "desc";
        }
        state.recordMobileExpanded = null;
        renderAll();
      }

      function renderRecordRows(rows) {
        const tbody = document.getElementById("recordRows");
        const mobileList = document.getElementById("recordMobileList");
        if (!rows.length) {
          tbody.innerHTML = `<tr><td colspan="14">No rows for current filters.</td></tr>`;
          if (mobileList) mobileList.innerHTML = `<div class="note">No rows for current filters.</div>`;
          updateRecordSortHeaderUI();
          return;
        }

        const ratioNorm = seqScale(rows.filter((r) => r.saleToList > 0).map((r) => r.saleToList));
        const deltaNorm = divScale(rows.map((r) => r.delta));
        const sortedRows = applyRecordSort(rows);

        tbody.innerHTML = sortedRows
          .map((r) => {
            const nActive = state.interactions.neighborhood === r.neighborhoodLabel;
            const tActive = state.interactions.type === r.typeLabel;
            const countyUrl = countyRecordUrl(r);
            const addrBadge = addressSourceBadgeHtml(r.addressSource);
            return `
              <tr>
                <td>
                  <a class="address-link" href="${esc(zillowUrl(r))}" target="_blank" rel="noopener noreferrer">${esc(r.address)}<span class="ext-icon" aria-hidden="true">&#8599;</span></a>
                  ${countyUrl ? `<a class="addr-sub-link" href="${esc(countyUrl)}" target="_blank" rel="noopener noreferrer">KC Record</a>` : ""}
                  ${addrBadge}
                </td>
                <td><button class="mini-btn ${nActive ? "active" : ""}" data-set-interaction="neighborhood" data-set-value="${esc(r.neighborhoodLabel)}">${esc(r.neighborhoodLabel)}</button></td>
                <td><button class="mini-btn ${tActive ? "active" : ""}" data-set-interaction="type" data-set-value="${esc(r.typeLabel)}">${esc(r.typeLabel)}</button></td>
                <td>${r.beds || 0}</td>
                <td>${r.baths ? r.baths.toFixed(2) : "0.00"}</td>
                <td>${r.sqft ? r.sqft.toLocaleString("en-US") : "0"}</td>
                <td>${esc(r.saleDate || "n/a")}</td>
                <td>${closeDisplay(r)}</td>
                <td>${formatMoney(r.listPriceAtPending)}</td>
                <td>${domLabel(r)}</td>
                <td>${hotCategoryBadge(r)}</td>
                <td><span class="heat" style="${seqHeat(r.saleToList > 0 ? ratioNorm(r.saleToList) : 0, "rgba(61,213,157,0.33)")}">${r.saleToList > 0 ? `${r.saleToList.toFixed(2)}x` : "n/a"}</span></td>
                <td><span class="heat" style="${divHeat(deltaNorm(r.delta))}">${deltaDisplay(r)}</span></td>
                <td><span class="mode">${esc(r.dataMode)}${r.isProjectionRow ? " PROJ" : ""}</span></td>
              </tr>
            `;
          })
          .join("");
        if (mobileList) {
          mobileList.innerHTML = sortedRows.map((r, idx) => {
            const key = `${r.id || "row"}|${r.saleDate || "date"}|${idx}`;
            const expanded = state.recordMobileExpanded === key;
            const nActive = state.interactions.neighborhood === r.neighborhoodLabel;
            const tActive = state.interactions.type === r.typeLabel;
            const countyUrl = countyRecordUrl(r);
            const addrBadge = addressSourceBadgeHtml(r.addressSource);
            return `
              <article class="mrow ${expanded ? "expanded" : ""}">
                <button class="mrow-head" type="button" data-mobile-expand="${esc(key)}">
                  <span class="mrow-address">${esc(r.address)} ${addrBadge}</span>
                  <span class="mrow-price">${closeDisplay(r)}</span>
                  <span class="mrow-date">${esc(r.saleDate || r.pendingDate || "n/a")} <span class="mrow-toggle">${expanded ? "Hide" : "More"}</span></span>
                </button>
                <div class="mrow-detail">
                  <div class="mrow-grid">
                    <div class="mrow-item"><div class="k">Links</div><div class="v"><a class="address-link" href="${esc(zillowUrl(r))}" target="_blank" rel="noopener noreferrer">Zillow<span class="ext-icon" aria-hidden="true">&#8599;</span></a>${countyUrl ? `<a class="addr-sub-link" href="${esc(countyUrl)}" target="_blank" rel="noopener noreferrer">KC Record</a>` : ""}</div></div>
                    <div class="mrow-item"><div class="k">Neighborhood</div><div class="v"><button class="mini-btn ${nActive ? "active" : ""}" data-set-interaction="neighborhood" data-set-value="${esc(r.neighborhoodLabel)}">${esc(r.neighborhoodLabel)}</button></div></div>
                    <div class="mrow-item"><div class="k">Type</div><div class="v"><button class="mini-btn ${tActive ? "active" : ""}" data-set-interaction="type" data-set-value="${esc(r.typeLabel)}">${esc(r.typeLabel)}</button></div></div>
                    <div class="mrow-item"><div class="k">Beds / Baths</div><div class="v">${r.beds || 0} / ${r.baths ? r.baths.toFixed(2) : "0.00"}</div></div>
                    <div class="mrow-item"><div class="k">SqFt</div><div class="v">${r.sqft ? r.sqft.toLocaleString("en-US") : "0"}</div></div>
                    <div class="mrow-item"><div class="k">Sale Price</div><div class="v">${closeDisplay(r)}</div></div>
                    <div class="mrow-item"><div class="k">List@Pending</div><div class="v">${formatMoney(r.listPriceAtPending)}</div></div>
                    <div class="mrow-item"><div class="k">DOM</div><div class="v">${domLabel(r)}</div></div>
                    <div class="mrow-item"><div class="k">Sale / List</div><div class="v">${r.saleToList > 0 ? `${r.saleToList.toFixed(2)}x` : "n/a"}</div></div>
                    <div class="mrow-item"><div class="k">Delta vs List@Pending</div><div class="v">${deltaDisplay(r)}</div></div>
                    <div class="mrow-item"><div class="k">Hot Category</div><div class="v">${hotCategoryBadge(r)}</div></div>
                    <div class="mrow-item"><div class="k">Data Mode</div><div class="v"><span class="mode">${esc(r.dataMode)}${r.isProjectionRow ? " PROJ" : ""}</span></div></div>
                    ${r.isProjectionRow && r.projectedCloseLow > 0 && r.projectedCloseHigh > 0
                      ? `<div class="mrow-item"><div class="k">Projected Range</div><div class="v">${formatMoney(r.projectedCloseLow)} - ${formatMoney(r.projectedCloseHigh)} (${r.projectionBasisCount} comps)</div></div>`
                      : ""}
                  </div>
                </div>
              </article>
            `;
          }).join("");
        }
        updateRecordSortHeaderUI();
      }

      function renderAll() {
        const baseRows = computeBaseRows();
        state.baseRows = baseRows;
        const stats = computeBaseStats(baseRows);
        const filtered = applyInteractions(baseRows, stats);
        const projectedRows = computeProjectedPendingRows(filtered, stats);
        const viewRows = projectedRows.length ? [...filtered, ...projectedRows] : filtered;
        if (state.geo.selectedPropertyKeys.length) {
          const validMapKeys = new Set(viewRows.map((r) => r.mapPropertyKey));
          state.geo.selectedPropertyKeys = state.geo.selectedPropertyKeys.filter((k) => validMapKeys.has(k));
        }
        state.filteredRows = viewRows;

        renderSummary(filtered, baseRows, projectedRows.length);
        renderChips();
        renderKpis(filtered, stats);
        renderInsights(filtered);
        renderCharts(filtered);
        renderHotMarket(filtered);
        renderGeo(viewRows);
        renderRatioRows(filtered);
        renderRankRows(filtered);
        renderRecordRows(viewRows);
      }

      function setInteraction(key, value) {
        state.interactions[key] = state.interactions[key] === value ? null : value;
        renderAll();
      }

      function clearCrossFilters() {
        Object.keys(state.interactions).forEach((k) => { state.interactions[k] = null; });
        state.geo.selectedPropertyKeys = [];
        state.geo.viewportFilter = false;
        renderAll();
      }

      function resetFormFilters() {
        applyDefaultFormFilters();
      }

      function escapeCsv(v) {
        const s = String(v ?? "");
        if (s.includes(",") || s.includes('"') || s.includes("\n")) return `"${s.replace(/"/g, '""')}"`;
        return s;
      }

      function exportFilteredCsv() {
        if (!state.filteredRows.length) return;
        const headers = [
          "id","address","neighborhood","type","dataMode","saleDate","listDate","pendingDate",
          "closePrice","listPriceAtPending","saleToList","delta","deltaPct","isHotMarket","isUltraHot",
          "hotCategory","domDays","isProjectionRow","projectedClosePrice","projectedCloseLow","projectedCloseHigh","projectionBasisCount",
          "beds","baths","sqft","yearBuilt","zip"
        ];
        const lines = [headers.join(",")];
        state.filteredRows.forEach((r) => {
          lines.push([
            r.id,
            r.address,
            r.neighborhoodLabel,
            r.typeLabel,
            r.dataMode,
            r.saleDate,
            r.listDate,
            r.pendingDate,
            r.closePrice,
            r.listPriceAtPending,
            r.saleToList,
            r.delta,
            r.deltaPct,
            r.isHotMarket ? "true" : "false",
            r.isUltraHot ? "true" : "false",
            hotCategory(r),
            domMetric(r) ?? "",
            r.isProjectionRow ? "true" : "false",
            r.projectedClosePrice || "",
            r.projectedCloseLow || "",
            r.projectedCloseHigh || "",
            r.projectionBasisCount || "",
            r.beds,
            r.baths,
            r.sqft,
            r.yearBuilt,
            r.zip,
          ].map(escapeCsv).join(","));
        });

        const blob = new Blob([lines.join("\n")], { type: "text/csv;charset=utf-8;" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "seattle_buyer_lens_filtered.csv";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      function applyTheme(theme) {
        const body = document.body;
        body.classList.remove("light", "dark");
        body.classList.add(theme);
        const toggle = document.getElementById("themeToggle");
        if (toggle) {
          toggle.textContent = theme === "light" ? "Switch To Dark Mode" : "Switch To Light Mode";
        }
        try {
          localStorage.setItem("buyer_lens_theme", theme);
        } catch (err) {
          // ignore storage errors
        }
      }

      function initTheme() {
        let saved = "light";
        try {
          saved = localStorage.getItem("buyer_lens_theme") || "light";
        } catch (err) {
          saved = "light";
        }
        applyTheme(saved === "dark" ? "dark" : "light");
      }

      function lockDateInputsToPicker() {
        ["fDateFrom", "fDateTo"].forEach((id) => {
          const el = document.getElementById(id);
          if (!el) return;
          el.setAttribute("inputmode", "none");
          el.setAttribute("autocomplete", "off");

          const openPicker = () => {
            if (typeof el.showPicker === "function") {
              try {
                el.showPicker();
              } catch (err) {
                // ignore picker invocation errors
              }
            }
          };

          el.addEventListener("focus", openPicker);
          el.addEventListener("click", openPicker);
          el.addEventListener("keydown", (evt) => {
            if (evt.key === "Backspace" || evt.key === "Delete") {
              if (el.value) {
                el.value = "";
                renderAll();
              }
              evt.preventDefault();
              return;
            }
            if (evt.key === "Tab" || evt.key === "Escape" || evt.key === "Enter") return;
            evt.preventDefault();
          });
          el.addEventListener("paste", (evt) => evt.preventDefault());
          el.addEventListener("drop", (evt) => evt.preventDefault());
        });
      }

      function bindEvents() {
        ["fType", "fMode", "fScope", "fDateFrom", "fDateTo"].forEach((id) => {
          const el = document.getElementById(id);
          el.addEventListener("input", renderAll);
          el.addEventListener("change", renderAll);
        });
        const projectionToggle = document.getElementById("ffProjection");
        if (projectionToggle) {
          projectionToggle.checked = !!state.flags.projection;
          projectionToggle.addEventListener("change", (evt) => {
            state.flags.projection = !!evt.target.checked;
            renderAll();
          });
        }
        lockDateInputsToPicker();
        ["fMinClose", "fMaxClose"].forEach((id) => {
          const el = document.getElementById(id);
          el.addEventListener("input", () => {
            syncPriceSliderPair(id);
            renderAll();
          });
          el.addEventListener("change", () => {
            syncPriceSliderPair(id);
            renderAll();
          });
        });

        const nOptions = document.getElementById("fNeighborhoodOptions");
        nOptions.addEventListener("change", (evt) => {
          if (!evt.target.matches("input[type='checkbox']")) return;
          updateNeighborhoodSummary();
          renderAll();
        });
        document.getElementById("fNeighborhoodSelectAll").addEventListener("click", () => {
          const all = [...document.querySelectorAll("#fNeighborhoodOptions input[type='checkbox']")].map((cb) => cb.value);
          setNeighborhoodSelections(all);
          updateNeighborhoodSummary();
          renderAll();
        });
        document.getElementById("fNeighborhoodClear").addEventListener("click", () => {
          setNeighborhoodSelections([]);
          updateNeighborhoodSummary();
          renderAll();
        });

        document.getElementById("resetBtn").addEventListener("click", () => {
          resetFormFilters();
          clearCrossFilters();
        });
        document.getElementById("clearCrossBtn").addEventListener("click", clearCrossFilters);
        document.getElementById("geoClearSelection").addEventListener("click", () => clearMapPropertySelection());
        document.getElementById("geoViewportFilter").addEventListener("change", (evt) => {
          state.geo.viewportFilter = !!evt.target.checked;
          const map = state.geo.map;
          if (state.geo.viewportFilter && map) {
            const b = map.getBounds();
            state.geo.mapBounds = {
              north: b.getNorth(),
              south: b.getSouth(),
              east: b.getEast(),
              west: b.getWest(),
            };
          }
          renderAll();
        });
        document.getElementById("exportCsvBtn").addEventListener("click", exportFilteredCsv);
        document.getElementById("themeToggle").addEventListener("click", () => {
          const next = document.body.classList.contains("light") ? "dark" : "light";
          applyTheme(next);
        });
        document.getElementById("globalFilters").addEventListener("toggle", () => {
          const dd = document.getElementById("fNeighborhood");
          if (!document.getElementById("globalFilters").open) dd.removeAttribute("open");
        });

        document.querySelectorAll(".tab").forEach((btn) => {
          btn.addEventListener("click", () => {
            document.querySelectorAll(".tab").forEach((x) => x.classList.remove("active"));
            btn.classList.add("active");
            const target = btn.getAttribute("data-view");
            document.querySelectorAll(".view").forEach((v) => v.classList.toggle("active", v.id === `view-${target}`));
            if (target === "geo" && state.geo.map) {
              setTimeout(() => state.geo.map.invalidateSize(), 40);
            }
          });
        });

        document.addEventListener("click", (evt) => {
          const sortBtn = evt.target.closest("[data-record-sort]");
          if (sortBtn) {
            setRecordSort(sortBtn.getAttribute("data-record-sort"));
            return;
          }

          const mobileExpand = evt.target.closest("[data-mobile-expand]");
          if (mobileExpand) {
            const key = mobileExpand.getAttribute("data-mobile-expand");
            state.recordMobileExpanded = state.recordMobileExpanded === key ? null : key;
            renderRecordRows(state.filteredRows);
            return;
          }

          const set = evt.target.closest("[data-set-interaction]");
          if (set) {
            setInteraction(set.getAttribute("data-set-interaction"), set.getAttribute("data-set-value"));
            return;
          }

          const clear = evt.target.closest("[data-clear-interaction]");
          if (clear) {
            const key = clear.getAttribute("data-clear-interaction");
            state.interactions[key] = null;
            renderAll();
            return;
          }

          const clearMap = evt.target.closest("[data-clear-map-selection]");
          if (clearMap) {
            clearMapPropertySelection();
            return;
          }

          const clearViewport = evt.target.closest("[data-clear-viewport-filter]");
          if (clearViewport) {
            state.geo.viewportFilter = false;
            const toggle = document.getElementById("geoViewportFilter");
            if (toggle) toggle.checked = false;
            renderAll();
            return;
          }

          const clearFlag = evt.target.closest("[data-clear-flag]");
          if (clearFlag) {
            const key = clearFlag.getAttribute("data-clear-flag");
            if (key === "projection") {
              state.flags.projection = false;
              const flagEl = document.getElementById("ffProjection");
              if (flagEl) flagEl.checked = false;
              renderAll();
            }
            return;
          }

          const kpi = evt.target.closest("[data-kpi-action]");
          if (!kpi) return;
          const action = kpi.getAttribute("data-kpi-action");
          if (action === "clear") return clearCrossFilters();
          if (action === "closeTier") return setInteraction("closeTier", "aboveMedian");
          if (action === "ratioMid") return setInteraction("ratioBucket", "100to105");
          if (action === "ratioGt1") return setInteraction("ratioBucket", "gt100");
          if (action === "psfTier") return setInteraction("psfTier", "aboveMedian");
          if (action === "mlsOnly") return setInteraction("mode", "MLS_ENRICHED");
        });

        const csvInput = document.getElementById("csvFile");
        if (csvInput) {
          csvInput.addEventListener("change", (evt) => {
            const file = evt.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = () => {
              try {
                state.rows = parseCsv(reader.result);
                refreshSelectOptions();
                applyDefaultFormFilters();
                clearCrossFilters();
                document.getElementById("uploadStatus").textContent = `Loaded ${state.rows.length} rows from ${file.name}.`;
                document.getElementById("datasetStatus").textContent = `Using uploaded dataset: ${file.name} (${state.rows.length} rows).`;
              } catch (err) {
                document.getElementById("uploadStatus").textContent = `Upload failed: ${err.message}`;
              }
            };
            reader.readAsText(file);
          });
        }
      }

      async function autoLoadDefault() {
        const status = document.getElementById("datasetStatus");
        try {
          const response = await fetch(DEFAULT_DATASET, { cache: "no-store" });
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          const text = await response.text();
          state.rows = parseCsv(text);
          refreshSelectOptions();
          applyDefaultFormFilters();
          clearCrossFilters();
          document.getElementById("uploadStatus").textContent = `Auto-loaded ${DEFAULT_DATASET}.`;
          status.textContent = `Auto-loaded ${DEFAULT_DATASET} (${state.rows.length} rows).`;
        } catch (err) {
          state.rows = [];
          refreshSelectOptions();
          renderAll();
          status.textContent = "Auto-load unavailable. Serve over HTTP (scripts/serve.js) so the default dataset can load.";
        }
      }

      function init() {
        initTheme();
        bindEvents();
        autoLoadDefault();
      }

      init();
    </script>
  </body>
</html>
