<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Seattle Housing Buyer Lens</title>
    <style>
      :root {
        --bg: #f4f1eb;
        --card: #ffffff;
        --ink: #1e1f23;
        --muted: #676a74;
        --line: #ded7cb;
        --deep: #0e3b56;
        --deep-2: #1e638d;
        --warm: #8c5e20;
      }
      * { box-sizing: border-box; }
      body {
        margin: 0;
        color: var(--ink);
        font-family: "Iowan Old Style", "Palatino Linotype", Palatino, serif;
        background:
          radial-gradient(1000px 500px at 10% -20%, #ecdfca 0%, transparent 60%),
          radial-gradient(900px 500px at 90% -10%, #dfe8ee 0%, transparent 55%),
          var(--bg);
      }
      header {
        max-width: 1200px;
        margin: 0 auto;
        padding: 28px 22px 10px;
      }
      h1 {
        margin: 0;
        font-size: 34px;
        letter-spacing: 0.4px;
      }
      .sub {
        margin-top: 6px;
        color: var(--muted);
        font-size: 14px;
      }
      .status {
        margin-top: 8px;
        color: var(--muted);
        font-size: 12px;
      }
      .page-tabs {
        margin-top: 14px;
        display: inline-flex;
        border: 1px solid var(--line);
        border-radius: 999px;
        overflow: hidden;
        background: #fff;
      }
      .page-tab {
        border: none;
        background: transparent;
        padding: 9px 14px;
        font-size: 13px;
        cursor: pointer;
      }
      .page-tab.active {
        background: var(--deep);
        color: #fff;
      }
      .shell {
        max-width: 1200px;
        margin: 0 auto;
        padding: 14px 22px 28px;
        display: grid;
        gap: 14px;
      }
      .panel {
        background: var(--card);
        border: 1px solid var(--line);
        border-radius: 14px;
        padding: 14px;
        box-shadow: 0 8px 20px rgba(0,0,0,0.04);
      }
      .panel h3 {
        margin: 2px 0 10px;
        font-size: 18px;
      }
      .filters {
        display: grid;
        grid-template-columns: repeat(8, minmax(0, 1fr));
        gap: 10px;
      }
      .field label {
        display: block;
        font-size: 12px;
        color: var(--muted);
        margin-bottom: 4px;
      }
      select, input {
        width: 100%;
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 8px 10px;
        font-size: 14px;
        background: #fff;
      }
      .actions {
        display: flex;
        align-items: flex-end;
        gap: 8px;
      }
      .btn {
        border: 1px solid var(--deep);
        background: var(--deep);
        color: #fff;
        border-radius: 10px;
        padding: 9px 12px;
        font-size: 13px;
        cursor: pointer;
      }
      .btn.alt {
        background: #fff;
        color: var(--deep);
      }
      .filter-summary {
        margin-top: 8px;
        color: var(--muted);
        font-size: 12px;
      }
      .view { display: none; }
      .view.active { display: grid; gap: 14px; }
      .kpi-grid {
        display: grid;
        grid-template-columns: repeat(6, minmax(0, 1fr));
        gap: 10px;
      }
      .kpi {
        background: #fbfaf8;
        border: 1px solid var(--line);
        border-radius: 12px;
        padding: 10px;
      }
      .kpi .label {
        font-size: 12px;
        color: var(--muted);
      }
      .kpi .value {
        margin-top: 6px;
        font-size: 22px;
      }
      .insights {
        margin: 0;
        padding-left: 18px;
        color: #2b2e35;
        display: grid;
        gap: 7px;
      }
      .two-col {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 14px;
      }
      .chart {
        display: grid;
        gap: 8px;
      }
      .bar-row {
        display: grid;
        grid-template-columns: 100px 1fr 150px;
        gap: 8px;
        align-items: center;
        font-size: 13px;
      }
      .track {
        width: 100%;
        height: 11px;
        border-radius: 999px;
        background: #eee7dd;
        overflow: hidden;
      }
      .fill {
        height: 100%;
        background: linear-gradient(90deg, var(--deep), var(--deep-2));
      }
      .fill.warm { background: linear-gradient(90deg, #9d6a1f, #c58a36); }
      table {
        width: 100%;
        border-collapse: collapse;
        font-size: 13px;
      }
      th, td {
        text-align: left;
        padding: 8px 6px;
        border-bottom: 1px solid var(--line);
      }
      th {
        color: var(--muted);
        font-weight: 600;
      }
      .mode {
        display: inline-block;
        font-size: 11px;
        padding: 2px 8px;
        border-radius: 999px;
        border: 1px solid var(--line);
        background: #f3f4f6;
      }
      .mono {
        font-family: "SFMono-Regular", Menlo, Consolas, monospace;
        font-size: 12px;
        white-space: pre-wrap;
        background: #f6f6f4;
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 10px;
      }
      .note {
        margin-top: 8px;
        color: var(--muted);
        font-size: 12px;
      }
      @media (max-width: 1100px) {
        .filters { grid-template-columns: repeat(4, minmax(0, 1fr)); }
        .kpi-grid { grid-template-columns: repeat(3, minmax(0, 1fr)); }
        .two-col { grid-template-columns: 1fr; }
      }
      @media (max-width: 680px) {
        .filters { grid-template-columns: 1fr 1fr; }
        .kpi-grid { grid-template-columns: 1fr 1fr; }
        .actions { grid-column: span 2; }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Seattle Housing Buyer Lens</h1>
      <div class="sub">Public-record market view with MLS-ready schema. All charts and tables share one dynamic filter state.</div>
      <div class="page-tabs" role="tablist">
        <button class="page-tab active" data-view="brief" role="tab">Market Brief</button>
        <button class="page-tab" data-view="charts" role="tab">Charts</button>
        <button class="page-tab" data-view="records" role="tab">Records</button>
        <button class="page-tab" data-view="data" role="tab">Data</button>
      </div>
      <div class="status" id="datasetStatus">Initializing dataset...</div>
    </header>

    <main class="shell">
      <section class="panel">
        <h3>Filters</h3>
        <div class="filters">
          <div class="field">
            <label for="fNeighborhood">Neighborhood</label>
            <select id="fNeighborhood"></select>
          </div>
          <div class="field">
            <label for="fType">Property Type</label>
            <select id="fType"></select>
          </div>
          <div class="field">
            <label for="fMode">Data Mode</label>
            <select id="fMode">
              <option value="All">All</option>
              <option value="PUBLIC_PROXY">Public Proxy</option>
              <option value="MLS_ENRICHED">MLS Enriched</option>
            </select>
          </div>
          <div class="field">
            <label for="fScope">Scope</label>
            <select id="fScope">
              <option value="all">All Sales</option>
              <option value="pending7">MLS Pending <= 7 Days</option>
            </select>
          </div>
          <div class="field">
            <label for="fMinClose">Min Close Price</label>
            <input id="fMinClose" type="number" placeholder="1100000" />
          </div>
          <div class="field">
            <label for="fMaxClose">Max Close Price</label>
            <input id="fMaxClose" type="number" placeholder="1400000" />
          </div>
          <div class="field">
            <label for="fDateFrom">Sale Date From</label>
            <input id="fDateFrom" type="date" />
          </div>
          <div class="field">
            <label for="fDateTo">Sale Date To</label>
            <input id="fDateTo" type="date" />
          </div>
          <div class="actions">
            <button class="btn" id="exportCsvBtn" type="button">Export Filtered CSV</button>
            <button class="btn alt" id="resetBtn" type="button">Reset</button>
          </div>
        </div>
        <div class="filter-summary" id="filterSummary">No data loaded.</div>
      </section>

      <section id="view-brief" class="view active">
        <div class="kpi-grid">
          <div class="kpi"><div class="label">Sales Count</div><div class="value" id="kSales">0</div></div>
          <div class="kpi"><div class="label">Median Close Price</div><div class="value" id="kMedianClose">$0</div></div>
          <div class="kpi"><div class="label">Median Sale / Assessed</div><div class="value" id="kMedianSA">0.00x</div></div>
          <div class="kpi"><div class="label">Share Above Assessed</div><div class="value" id="kAboveAssessed">0%</div></div>
          <div class="kpi"><div class="label">Median Price / SqFt</div><div class="value" id="kPsf">$0</div></div>
          <div class="kpi"><div class="label">Median Days to Pending (MLS)</div><div class="value" id="kPendingDays">n/a</div></div>
        </div>
        <section class="panel">
          <h3>Buyer Notes</h3>
          <ul class="insights" id="insights"></ul>
        </section>
      </section>

      <section id="view-charts" class="view">
        <div class="two-col">
          <section class="panel">
            <h3>Monthly Sales Volume</h3>
            <div class="chart" id="chartVolume"></div>
          </section>
          <section class="panel">
            <h3>Monthly Median Close Price</h3>
            <div class="chart" id="chartMedianPrice"></div>
          </section>
        </div>
        <div class="two-col">
          <section class="panel">
            <h3>Sale / Assessed Distribution</h3>
            <table>
              <thead>
                <tr><th>Bucket</th><th>Count</th><th>Share</th><th>Median Close</th></tr>
              </thead>
              <tbody id="ratioRows"></tbody>
            </table>
          </section>
          <section class="panel">
            <h3>Neighborhood Leaderboard</h3>
            <table>
              <thead>
                <tr><th>Neighborhood</th><th>Count</th><th>Median Close</th><th>Median S/A</th></tr>
              </thead>
              <tbody id="rankRows"></tbody>
            </table>
          </section>
        </div>
      </section>

      <section id="view-records" class="view">
        <section class="panel">
          <h3>Row-Level Sales Summary</h3>
          <table>
            <thead>
              <tr>
                <th>Address</th>
                <th>Neighborhood</th>
                <th>Type</th>
                <th>Beds</th>
                <th>Baths</th>
                <th>SqFt</th>
                <th>Sale Date</th>
                <th>Close Price</th>
                <th>Assessed</th>
                <th>S/A</th>
                <th>Data Mode</th>
              </tr>
            </thead>
            <tbody id="recordRows"></tbody>
          </table>
          <div class="note">Public proxy rows use recorded sale data. MLS-enriched rows can carry true list/pending fields.</div>
        </section>
      </section>

      <section id="view-data" class="view">
        <section class="panel">
          <h3>Data Source and Upload</h3>
          <div class="note" id="uploadStatus">No file loaded.</div>
          <input id="csvFile" type="file" accept=".csv" />

          <p class="note">Auto-load target file name:</p>
          <div class="mono">public_sales_proxy_1p1m_1p4m_last6mo.csv</div>

          <p class="note">Minimum columns:</p>
          <div class="mono">id,address,type,closePrice</div>

          <p class="note">Recommended columns:</p>
          <div class="mono">dataMode,neighborhood,zip,listDate,pendingDate,saleDate,listPriceAtPending,assessedValue,beds,baths,sqft,yearBuilt,mlsListDate,mlsPendingDate,mlsListPriceAtPending,mlsClosePrice</div>

          <p class="note">Interpretation reminder:</p>
          <div class="mono">Public records do not include true original list date or pending date. In PUBLIC_PROXY mode, those fields are placeholders unless MLS fields are provided.</div>
        </section>
      </section>
    </main>

    <script>
      const DEFAULT_DATASET = "public_sales_proxy_1p1m_1p4m_last6mo.csv";

      const TYPE_LABELS = {
        "11": "Single-family house",
        "12": "Residential multi-family (2-4 units)",
        "13": "Residential multi-family (5+ units)",
        "14": "Residential condominium",
        "15": "Mobile home park/court",
        "18": "Other residential",
        "19": "Vacation/cabin",
        "50": "Commercial or non-residential condo",
        "91": "Undeveloped land",
      };

      const ZIP_NEIGHBORHOOD = {
        "98101": "Downtown",
        "98102": "Capitol Hill / Eastlake",
        "98103": "Fremont / Green Lake / Wallingford",
        "98104": "Pioneer Square / International District",
        "98105": "University District / Laurelhurst",
        "98106": "Delridge / South Park",
        "98107": "Ballard",
        "98108": "Georgetown / South Park",
        "98109": "South Lake Union / Queen Anne",
        "98112": "Capitol Hill / Madison Park",
        "98115": "Ravenna / Wedgwood",
        "98116": "West Seattle",
        "98117": "Ballard / Crown Hill",
        "98118": "Columbia City / Rainier Valley",
        "98119": "Queen Anne / Magnolia",
        "98121": "Belltown",
        "98122": "Capitol Hill / Central District",
        "98125": "Lake City / North Seattle",
        "98126": "West Seattle / Delridge",
        "98133": "Northgate / Bitter Lake",
        "98134": "SoDo",
        "98136": "West Seattle / Fauntleroy",
        "98144": "Mount Baker / Central District",
        "98177": "North Beach / Crown Hill",
        "98199": "Magnolia",
      };

      const state = {
        rows: [],
        filtered: [],
      };

      function toDate(value) {
        if (!value) return null;
        const v = String(value).trim();
        if (!v) return null;
        const isoDateLike = /^\d{4}-\d{2}-\d{2}$/;
        const d = isoDateLike.test(v) ? new Date(`${v}T00:00:00`) : new Date(v);
        return Number.isNaN(d.getTime()) ? null : d;
      }

      function toIso(value) {
        const d = toDate(value);
        if (!d) return "";
        const y = d.getFullYear();
        const m = String(d.getMonth() + 1).padStart(2, "0");
        const day = String(d.getDate()).padStart(2, "0");
        return `${y}-${m}-${day}`;
      }

      function num(value) {
        if (value === null || value === undefined || value === "") return 0;
        const n = Number(String(value).replace(/[^0-9.-]/g, ""));
        return Number.isFinite(n) ? n : 0;
      }

      function formatMoney(n) {
        return Number(n || 0).toLocaleString("en-US", {
          style: "currency",
          currency: "USD",
          maximumFractionDigits: 0,
        });
      }

      function median(arr) {
        if (!arr.length) return 0;
        const sorted = [...arr].sort((a, b) => a - b);
        const mid = Math.floor(sorted.length / 2);
        return sorted.length % 2 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
      }

      function daysBetween(a, b) {
        const d1 = toDate(a);
        const d2 = toDate(b);
        if (!d1 || !d2) return null;
        return Math.round((d2 - d1) / (1000 * 60 * 60 * 24));
      }

      function parseCsvLine(line) {
        const out = [];
        let cur = "";
        let inQuotes = false;
        for (let i = 0; i < line.length; i += 1) {
          const ch = line[i];
          if (ch === '"') {
            if (inQuotes && line[i + 1] === '"') {
              cur += '"';
              i += 1;
            } else {
              inQuotes = !inQuotes;
            }
          } else if (ch === "," && !inQuotes) {
            out.push(cur.trim());
            cur = "";
          } else {
            cur += ch;
          }
        }
        out.push(cur.trim());
        return out;
      }

      function parseCsv(text) {
        const lines = text.trim().split(/\r?\n/);
        if (lines.length < 2) return [];
        const headers = parseCsvLine(lines[0]);
        const idx = Object.fromEntries(headers.map((h, i) => [h, i]));
        const required = ["id", "address", "type", "closePrice"];
        const missing = required.filter((k) => idx[k] === undefined);
        if (missing.length) throw new Error(`Missing required columns: ${missing.join(", ")}`);

        return lines.slice(1).filter((line) => line.trim()).map((line) => {
          const cols = parseCsvLine(line);
          const pick = (name) => (idx[name] !== undefined ? (cols[idx[name]] || "").trim() : "");
          return {
            dataMode: pick("dataMode"),
            id: pick("id"),
            address: pick("address"),
            neighborhood: pick("neighborhood"),
            type: pick("type"),
            typeCode: pick("typeCode"),
            listDate: pick("listDate"),
            pendingDate: pick("pendingDate"),
            saleDate: pick("saleDate"),
            listPriceAtPending: num(pick("listPriceAtPending")),
            closePrice: num(pick("closePrice")),
            assessedValue: num(pick("assessedValue")),
            beds: num(pick("beds")),
            baths: num(pick("baths")),
            sqft: num(pick("sqft")),
            yearBuilt: num(pick("yearBuilt")),
            zip: pick("zip"),
            districtName: pick("districtName"),
            area: pick("area"),
            subArea: pick("subArea"),
            sqFtLot: num(pick("sqFtLot")),
            zoning: pick("zoning"),
            mlsListDate: pick("mlsListDate"),
            mlsPendingDate: pick("mlsPendingDate"),
            mlsListPriceAtPending: num(pick("mlsListPriceAtPending")),
            mlsClosePrice: num(pick("mlsClosePrice")),
          };
        });
      }

      function inferMode(row) {
        if (row.dataMode) return row.dataMode;
        const hasMls = row.mlsListDate || row.mlsPendingDate || row.mlsListPriceAtPending || row.mlsClosePrice;
        return hasMls ? "MLS_ENRICHED" : "PUBLIC_PROXY";
      }

      function labelNeighborhood(rawNeighborhood, zip) {
        const raw = String(rawNeighborhood || "").trim();
        if (/[a-z]/i.test(raw)) return raw;
        const z = (String(zip || "").match(/[0-9]{5}/) || [])[0] || "";
        if (ZIP_NEIGHBORHOOD[z]) return ZIP_NEIGHBORHOOD[z];
        if (/^981[0-9]{2}$/.test(z)) return `Seattle ${z}`;
        return "Seattle (Other)";
      }

      function labelType(rawType, typeCode) {
        const raw = String(rawType || "").trim();
        if (/[a-z]/i.test(raw)) return raw;
        const code = String(num(typeCode || raw) || "");
        return TYPE_LABELS[code] || (code ? `Type ${code}` : "Unknown");
      }

      function normalizeRow(source) {
        const dataMode = inferMode(source);
        const saleDate = source.saleDate || source.closeDate || source.pendingDate || source.listDate || source.mlsCloseDate || "";
        const listDate = source.mlsListDate || source.listDate || "";
        const pendingDate = source.mlsPendingDate || source.pendingDate || "";
        const closePrice = num(source.mlsClosePrice || source.closePrice);
        const assessedValue = num(source.assessedValue);
        const listPriceAtPending = num(source.mlsListPriceAtPending || source.listPriceAtPending || assessedValue || closePrice);
        const daysToPending = daysBetween(listDate, pendingDate);
        const saleToAssessed = assessedValue > 0 ? closePrice / assessedValue : 0;
        const delta = closePrice - listPriceAtPending;
        const deltaPct = listPriceAtPending > 0 ? delta / listPriceAtPending : 0;
        const pricePerSqft = source.sqft > 0 ? closePrice / source.sqft : 0;

        return {
          ...source,
          dataMode,
          typeLabel: labelType(source.type, source.typeCode),
          neighborhoodLabel: labelNeighborhood(source.neighborhood, source.zip),
          saleDate: toIso(saleDate),
          listDate: toIso(listDate),
          pendingDate: toIso(pendingDate),
          closePrice,
          assessedValue,
          listPriceAtPending,
          beds: num(source.beds),
          baths: num(source.baths),
          sqft: num(source.sqft),
          yearBuilt: num(source.yearBuilt),
          daysToPending,
          saleToAssessed,
          delta,
          deltaPct,
          pricePerSqft,
        };
      }

      function uniqueValues(rows, key) {
        return ["All", ...Array.from(new Set(rows.map((r) => r[key]).filter(Boolean))).sort()];
      }

      function populateFilters() {
        const normalized = state.rows.map(normalizeRow);

        const neighborhoodOptions = uniqueValues(normalized, "neighborhoodLabel");
        document.getElementById("fNeighborhood").innerHTML = neighborhoodOptions
          .map((v) => `<option value="${v}">${v}</option>`)
          .join("");

        const typeOptions = uniqueValues(normalized, "typeLabel");
        document.getElementById("fType").innerHTML = typeOptions
          .map((v) => `<option value="${v}">${v}</option>`)
          .join("");
      }

      function readFilters() {
        return {
          neighborhood: document.getElementById("fNeighborhood").value,
          type: document.getElementById("fType").value,
          mode: document.getElementById("fMode").value,
          scope: document.getElementById("fScope").value,
          minClose: num(document.getElementById("fMinClose").value),
          maxClose: num(document.getElementById("fMaxClose").value),
          dateFrom: document.getElementById("fDateFrom").value,
          dateTo: document.getElementById("fDateTo").value,
        };
      }

      function applyFilters() {
        const f = readFilters();
        let rows = state.rows.map(normalizeRow).filter((r) => r.closePrice > 0 && !!r.saleDate);

        if (f.neighborhood !== "All") rows = rows.filter((r) => r.neighborhoodLabel === f.neighborhood);
        if (f.type !== "All") rows = rows.filter((r) => r.typeLabel === f.type);
        if (f.mode !== "All") rows = rows.filter((r) => r.dataMode === f.mode);
        if (f.minClose) rows = rows.filter((r) => r.closePrice >= f.minClose);
        if (f.maxClose) rows = rows.filter((r) => r.closePrice <= f.maxClose);
        if (f.dateFrom) rows = rows.filter((r) => r.saleDate >= f.dateFrom);
        if (f.dateTo) rows = rows.filter((r) => r.saleDate <= f.dateTo);

        if (f.scope === "pending7") {
          rows = rows.filter((r) => r.dataMode === "MLS_ENRICHED" && r.daysToPending !== null && r.daysToPending <= 7);
        }

        state.filtered = rows;
        renderAll();
      }

      function renderFilterSummary(rows) {
        const mlsCount = rows.filter((r) => r.dataMode === "MLS_ENRICHED").length;
        const publicCount = rows.length - mlsCount;
        document.getElementById("filterSummary").textContent =
          `Showing ${rows.length} sales | ${publicCount} Public Proxy | ${mlsCount} MLS Enriched`;
      }

      function renderKpis(rows) {
        const medianClose = median(rows.map((r) => r.closePrice));
        const ratios = rows.filter((r) => r.saleToAssessed > 0).map((r) => r.saleToAssessed);
        const overAssessedPct = ratios.length ? (ratios.filter((v) => v > 1).length / ratios.length) * 100 : 0;
        const psfMedian = median(rows.filter((r) => r.pricePerSqft > 0).map((r) => r.pricePerSqft));
        const mlsPending = rows.filter((r) => r.dataMode === "MLS_ENRICHED" && r.daysToPending !== null).map((r) => r.daysToPending);

        document.getElementById("kSales").textContent = rows.length;
        document.getElementById("kMedianClose").textContent = formatMoney(medianClose);
        document.getElementById("kMedianSA").textContent = `${median(ratios).toFixed(2)}x`;
        document.getElementById("kAboveAssessed").textContent = `${overAssessedPct.toFixed(1)}%`;
        document.getElementById("kPsf").textContent = formatMoney(psfMedian);
        document.getElementById("kPendingDays").textContent = mlsPending.length ? `${median(mlsPending).toFixed(0)} days` : "n/a";
      }

      function monthKey(isoDate) {
        const d = toDate(isoDate);
        if (!d) return "Unknown";
        return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, "0")}`;
      }

      function renderBarChart(containerId, items, valueAccessor, labelAccessor, tailAccessor, warm) {
        const el = document.getElementById(containerId);
        if (!items.length) {
          el.innerHTML = `<div class="note">No rows for current filters.</div>`;
          return;
        }
        const max = Math.max(...items.map((i) => valueAccessor(i)), 1);
        el.innerHTML = items.map((item) => {
          const value = valueAccessor(item);
          const width = Math.round((value / max) * 100);
          return `
            <div class="bar-row">
              <div>${labelAccessor(item)}</div>
              <div class="track"><div class="fill ${warm ? "warm" : ""}" style="width:${width}%"></div></div>
              <div>${tailAccessor(item)}</div>
            </div>
          `;
        }).join("");
      }

      function renderVolumeChart(rows) {
        const grouped = {};
        rows.forEach((r) => {
          const key = monthKey(r.saleDate);
          if (!grouped[key]) grouped[key] = { month: key, count: 0 };
          grouped[key].count += 1;
        });
        const items = Object.values(grouped).sort((a, b) => a.month.localeCompare(b.month));
        renderBarChart(
          "chartVolume",
          items,
          (i) => i.count,
          (i) => i.month,
          (i) => `${i.count} sales`,
          false
        );
      }

      function renderMedianPriceChart(rows) {
        const grouped = {};
        rows.forEach((r) => {
          const key = monthKey(r.saleDate);
          if (!grouped[key]) grouped[key] = [];
          grouped[key].push(r.closePrice);
        });
        const items = Object.entries(grouped)
          .map(([month, prices]) => ({ month, medianPrice: median(prices) }))
          .sort((a, b) => a.month.localeCompare(b.month));
        renderBarChart(
          "chartMedianPrice",
          items,
          (i) => i.medianPrice,
          (i) => i.month,
          (i) => formatMoney(i.medianPrice),
          true
        );
      }

      function renderRatioBuckets(rows) {
        const tbody = document.getElementById("ratioRows");
        if (!rows.length) {
          tbody.innerHTML = `<tr><td colspan="4">No rows for current filters.</td></tr>`;
          return;
        }
        const buckets = [
          { label: "< 0.95x", min: -Infinity, max: 0.95 },
          { label: "0.95x - 1.00x", min: 0.95, max: 1.0 },
          { label: "1.00x - 1.05x", min: 1.0, max: 1.05 },
          { label: "> 1.05x", min: 1.05, max: Infinity },
        ];
        const total = rows.length;
        tbody.innerHTML = buckets.map((b) => {
          const set = rows.filter((r) => r.saleToAssessed > b.min && r.saleToAssessed <= b.max);
          const share = total ? ((set.length / total) * 100).toFixed(1) : "0.0";
          return `
            <tr>
              <td>${b.label}</td>
              <td>${set.length}</td>
              <td>${share}%</td>
              <td>${formatMoney(median(set.map((r) => r.closePrice)))}</td>
            </tr>
          `;
        }).join("");
      }

      function renderRankTable(rows) {
        const tbody = document.getElementById("rankRows");
        if (!rows.length) {
          tbody.innerHTML = `<tr><td colspan="4">No rows for current filters.</td></tr>`;
          return;
        }
        const grouped = {};
        rows.forEach((r) => {
          if (!grouped[r.neighborhoodLabel]) grouped[r.neighborhoodLabel] = [];
          grouped[r.neighborhoodLabel].push(r);
        });
        const ranked = Object.entries(grouped)
          .map(([name, set]) => ({
            name,
            count: set.length,
            medianClose: median(set.map((r) => r.closePrice)),
            medianSA: median(set.filter((r) => r.saleToAssessed > 0).map((r) => r.saleToAssessed)),
          }))
          .sort((a, b) => (b.count - a.count) || (b.medianClose - a.medianClose))
          .slice(0, 15);

        tbody.innerHTML = ranked.map((r) => `
          <tr>
            <td>${r.name}</td>
            <td>${r.count}</td>
            <td>${formatMoney(r.medianClose)}</td>
            <td>${r.medianSA.toFixed(2)}x</td>
          </tr>
        `).join("");
      }

      function renderInsights(rows) {
        const el = document.getElementById("insights");
        if (!rows.length) {
          el.innerHTML = `<li>No rows match current filters. Widen price/date or switch scope back to All Sales.</li>`;
          return;
        }

        const medianClose = median(rows.map((r) => r.closePrice));
        const medianSA = median(rows.filter((r) => r.saleToAssessed > 0).map((r) => r.saleToAssessed));
        const overShare = rows.filter((r) => r.saleToAssessed > 1).length / rows.length;
        const groupedByNeighborhood = {};
        rows.forEach((r) => {
          groupedByNeighborhood[r.neighborhoodLabel] = (groupedByNeighborhood[r.neighborhoodLabel] || 0) + 1;
        });
        const topNeighborhood = Object.entries(groupedByNeighborhood).sort((a, b) => b[1] - a[1])[0];

        const monthlyCounts = {};
        rows.forEach((r) => {
          const m = monthKey(r.saleDate);
          monthlyCounts[m] = (monthlyCounts[m] || 0) + 1;
        });
        const hottestMonth = Object.entries(monthlyCounts).sort((a, b) => b[1] - a[1])[0];

        const mlsRows = rows.filter((r) => r.dataMode === "MLS_ENRICHED" && r.daysToPending !== null);
        const publicShare = rows.filter((r) => r.dataMode === "PUBLIC_PROXY").length / rows.length;

        const lines = [
          `Median close price in this slice is ${formatMoney(medianClose)} across ${rows.length} sales.`,
          `${(overShare * 100).toFixed(1)}% of homes closed above assessed value (median S/A ${medianSA.toFixed(2)}x).`,
          `Most active neighborhood in this filter is ${topNeighborhood ? topNeighborhood[0] : "n/a"} (${topNeighborhood ? topNeighborhood[1] : 0} sales).`,
          `Peak month in this view is ${hottestMonth ? hottestMonth[0] : "n/a"} (${hottestMonth ? hottestMonth[1] : 0} sales).`,
        ];

        if (mlsRows.length) {
          lines.push(`MLS-enriched subset shows median ${median(mlsRows.map((r) => r.daysToPending)).toFixed(0)} days to pending.`);
        } else {
          lines.push("No MLS-enriched rows in this filter, so true days-to-pending/list-to-close metrics are unavailable here.");
        }

        if (publicShare >= 0.5) {
          lines.push("Public Proxy mode uses recorded sale data; list and pending dates are placeholders unless MLS fields are supplied.");
        }

        el.innerHTML = lines.map((line) => `<li>${line}</li>`).join("");
      }

      function renderRecords(rows) {
        const tbody = document.getElementById("recordRows");
        if (!rows.length) {
          tbody.innerHTML = `<tr><td colspan="11">No rows for current filters.</td></tr>`;
          return;
        }
        tbody.innerHTML = rows
          .slice()
          .sort((a, b) => b.saleDate.localeCompare(a.saleDate))
          .map((r) => `
            <tr>
              <td>${r.address}</td>
              <td>${r.neighborhoodLabel}</td>
              <td>${r.typeLabel}</td>
              <td>${r.beds || 0}</td>
              <td>${r.baths ? r.baths.toFixed(2) : "0.00"}</td>
              <td>${r.sqft ? r.sqft.toLocaleString("en-US") : "0"}</td>
              <td>${r.saleDate || "n/a"}</td>
              <td>${formatMoney(r.closePrice)}</td>
              <td>${formatMoney(r.assessedValue)}</td>
              <td>${r.saleToAssessed > 0 ? `${r.saleToAssessed.toFixed(2)}x` : "n/a"}</td>
              <td><span class="mode">${r.dataMode}</span></td>
            </tr>
          `)
          .join("");
      }

      function renderAll() {
        const rows = state.filtered;
        renderFilterSummary(rows);
        renderKpis(rows);
        renderInsights(rows);
        renderVolumeChart(rows);
        renderMedianPriceChart(rows);
        renderRatioBuckets(rows);
        renderRankTable(rows);
        renderRecords(rows);
      }

      function resetFilters() {
        document.getElementById("fNeighborhood").value = "All";
        document.getElementById("fType").value = "All";
        document.getElementById("fMode").value = "All";
        document.getElementById("fScope").value = "all";
        document.getElementById("fMinClose").value = "";
        document.getElementById("fMaxClose").value = "";
        document.getElementById("fDateFrom").value = "";
        document.getElementById("fDateTo").value = "";
        applyFilters();
      }

      function escapeCsv(value) {
        const text = String(value ?? "");
        if (text.includes(",") || text.includes('"') || text.includes("\n")) {
          return `"${text.replace(/"/g, '""')}"`;
        }
        return text;
      }

      function exportFilteredCsv() {
        const rows = state.filtered;
        if (!rows.length) return;
        const headers = [
          "id","address","neighborhood","type","dataMode","saleDate","listDate","pendingDate",
          "closePrice","assessedValue","saleToAssessed","listPriceAtPending","delta","deltaPct",
          "beds","baths","sqft","yearBuilt","zip"
        ];
        const lines = [headers.join(",")];
        rows.forEach((r) => {
          lines.push([
            r.id,
            r.address,
            r.neighborhoodLabel,
            r.typeLabel,
            r.dataMode,
            r.saleDate,
            r.listDate,
            r.pendingDate,
            r.closePrice,
            r.assessedValue,
            r.saleToAssessed,
            r.listPriceAtPending,
            r.delta,
            r.deltaPct,
            r.beds,
            r.baths,
            r.sqft,
            r.yearBuilt,
            r.zip,
          ].map(escapeCsv).join(","));
        });

        const blob = new Blob([lines.join("\n")], { type: "text/csv;charset=utf-8;" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "seattle_buyer_lens_filtered.csv";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      async function autoLoadDefault() {
        const status = document.getElementById("datasetStatus");
        try {
          const response = await fetch(DEFAULT_DATASET, { cache: "no-store" });
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          const text = await response.text();
          state.rows = parseCsv(text);
          populateFilters();
          applyFilters();
          document.getElementById("uploadStatus").textContent = `Auto-loaded ${DEFAULT_DATASET}.`;
          status.textContent = `Auto-loaded ${DEFAULT_DATASET} (${state.rows.length} rows).`;
        } catch (err) {
          status.textContent = "Auto-load unavailable. Serve over HTTP (scripts/serve.js) or upload CSV in Data tab.";
          state.rows = [];
          populateFilters();
          applyFilters();
        }
      }

      function bindEvents() {
        ["fNeighborhood", "fType", "fMode", "fScope", "fMinClose", "fMaxClose", "fDateFrom", "fDateTo"]
          .forEach((id) => {
            document.getElementById(id).addEventListener("input", applyFilters);
            document.getElementById(id).addEventListener("change", applyFilters);
          });

        document.getElementById("exportCsvBtn").addEventListener("click", exportFilteredCsv);
        document.getElementById("resetBtn").addEventListener("click", resetFilters);

        document.querySelectorAll(".page-tab").forEach((btn) => {
          btn.addEventListener("click", () => {
            document.querySelectorAll(".page-tab").forEach((b) => b.classList.remove("active"));
            btn.classList.add("active");
            const target = btn.getAttribute("data-view");
            document.querySelectorAll(".view").forEach((view) => {
              view.classList.toggle("active", view.id === `view-${target}`);
            });
          });
        });

        document.getElementById("csvFile").addEventListener("change", (evt) => {
          const file = evt.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = () => {
            try {
              state.rows = parseCsv(reader.result);
              populateFilters();
              applyFilters();
              document.getElementById("uploadStatus").textContent = `Loaded ${state.rows.length} rows from ${file.name}.`;
              document.getElementById("datasetStatus").textContent = `Using uploaded dataset: ${file.name} (${state.rows.length} rows).`;
            } catch (err) {
              document.getElementById("uploadStatus").textContent = `Upload failed: ${err.message}`;
            }
          };
          reader.readAsText(file);
        });
      }

      function init() {
        bindEvents();
        autoLoadDefault();
      }

      init();
    </script>
  </body>
</html>
